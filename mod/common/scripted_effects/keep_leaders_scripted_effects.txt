# creates a country to store leaders and variables counting them, then transfers and counts them
# this = any (uses event_targets for all logic)
# event_target:potential_owner = country, overlord/infiltrator/planet-killer
# event_target:former_owner = country, integrated subject/pre-FTLs/victims
create_leader_storage_and_transfer_leaders = {
	optimize_memory
	# auto_delete = no # required only if country_type has auto_delete = yes (the default)
	# ignore_initial_colony_error = yes # required only if country_type has needs_colony = yes (the default)
	if = {
		limit = {
			event_target:former_owner = {
				NOR = {
					is_country_type = primitive
					is_country_type = enclave
					is_country_type = enclave_mercenary
					is_country_type = fallen_empire
					is_country_type = sentinels
					is_country_type = ai_empire
					is_country_type = dormant_marauders
					is_country_type = awakened_marauders
					is_country_type = caravaneer_home
					is_country_type = caravaneer_fleet
				}
			}
		}
		create_country = {
			name = event_target:former_owner
			adjective = event_target:former_owner
			type = keep_leaders_container
			species = event_target:former_owner
			flag = event_target:former_owner
			authority = event_target:former_owner
			ethos = event_target:former_owner
			civics = event_target:former_owner
			ship_prefix = event_target:former_owner
			effect = { save_event_target_as = storage_owner }
		}
	}
	else = { # country_type-specific civics cannot be copied because they are explicitly restricted to the primitive country_type
		create_country = {
			name = event_target:former_owner
			adjective = event_target:former_owner
			type = keep_leaders_container
			species = event_target:former_owner
			flag = event_target:former_owner
			authority = event_target:former_owner
			ethos = event_target:former_owner
			ship_prefix = event_target:former_owner
			effect = { save_event_target_as = storage_owner }
		}
	}
	event_target:storage_owner = { # set up additional "arguments" for accumulate_leader and transfer_leader_to_storage
		copy_flags_and_variables_from = event_target:former_owner
		if = {
			limit = { event_target:former_owner = { is_regular_empire_or_primitive = yes } }
			set_country_flag = regular_empire_or_primitive_storage_owner
		}
		if = {
			limit = { event_target:former_owner = { is_primitive = yes } }
			set_country_flag = primitive_storage_owner
		}
		if = {
			limit = { event_target:former_owner = { is_gestalt = yes } }
			set_country_flag = gestalt_storage_owner
		}
		if = {
			limit = { event_target:former_owner = { is_hive_empire = yes } }
			set_country_flag = hive_empire_storage_owner
		}
		if = {
			limit = { event_target:former_owner = { is_machine_empire = yes } }
			set_country_flag = machine_empire_storage_owner
		}
		set_country_flag = former_owner_shell
		set_country_flag = former_owner@event_target:former_owner
		set_country_flag = potential_owner@event_target:potential_owner
		save_event_target_as = variable_storage
		# variables for the counts from accumulate_leader
		set_variable = {
			which = leader_accumulator
			value = 0
		}
		set_variable = {
			which = leader_organic_accumulator
			value = 0
		}
		set_variable = {
			which = leader_hive_accumulator
			value = 0
		}
		set_variable = {
			which = leader_robotic_accumulator
			value = 0
		}
		set_variable = {
			which = leader_necrophagable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_same_species_accumulator
			value = 0
		}
		set_variable = {
			which = leader_not_same_species_accumulator
			value = 0
		}
		set_variable = {
			which = leader_transferable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_assimilation_cyborg_allowable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_assimilation_cyborg_allowable_accumulator_double
			value = 0
		}
		set_variable = {
			which = leader_assimilation_uncyborg_allowable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_assimilation_synthetic_allowable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_assimilation_unmachine_allowable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_assimilation_psionic_allowable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_assimilation_genetic_allowable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_transferable_or_assimilatable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_aquatic_accumulator
			value = 0
		}
	}
	# transfer leaders to storage and count them (see accumulate_leader)
	event_target:former_owner = {
		every_owned_leader = {
			limit = {
				is_eligible_transfer_leader = yes
				is_ruler = no
				is_heir = no
			}
			accumulate_leader = yes
			transfer_leader_to_storage = yes
		}
		# TODO - if I get persistent shells to work, clean up any former shells here (i.e. a ruler/heir transferred before)
		if = {
			limit = { exists = ruler }
			ruler = {
				set_name = {
					key = keep_leaders.former_ruler_name
					variable_string = "\\[This.GetRegnalName\\]"
					variable_string = "\\[former_owner.GetRulerTitle\\]"
					# variable_string = "\\[This.GetTitle\\]"
					variable_string = "\\[former_owner.GetName\\]"
				}
				set_leader_flag = former_ruler
				# set_leader_flag = former_owner_shell@event_target:storage_owner
				save_event_target_as = integrated_ruler
			}
			event_target:integrated_ruler = {
				accumulate_leader = yes
				try_process_gestalt_ruler = yes
				try_add_former_ruler_trait = yes
				transfer_leader_to_storage = yes
				event_target:storage_owner = { # assign the ruler as the ruler of the storage country - should help them appear with ruler clothing and allows use of related triggers
					ruler = { save_event_target_as = storage_ruler }
					assign_leader = prev
				}
				event_target:storage_ruler = { kill_leader = { show_notification = no } }
			}
		}
		if = {
			limit = { exists = heir }
			heir = {
				set_name = {
					key = keep_leaders.former_heir_name
					variable_string = "\\[This.GetName\\]"
					# variable_string = "\\[This.GetTitle\\]"
					variable_string = "\\[former_owner.GetName\\]"
				}
				set_leader_flag = former_heir
				# set_leader_flag = former_owner_shell@event_target:storage_owner
				save_event_target_as = integrated_heir
			}
			event_target:integrated_heir = {
				accumulate_leader = yes
				try_add_former_heir_trait = yes
				transfer_leader_to_storage = yes
				event_target:storage_owner = { set_heir = prev } # assign the heir as the heir of the storage country - allows use of related triggers
			}
		}
		set_country_flag = leader_storage_created
	}
}

# this = country, leader storage
# event_target:potential_owner = country, new owner of leaders from this leader storage country
try_clean_up_leader_storage = {
	if = {
		limit = { event_target:potential_owner = { NOT = { any_owned_leader = { has_leader_flag = former_owner_shell@prevprev } } } }
		destroy_country = yes
	}
	else = {
		every_owned_leader = {
			limit = {
				is_ruler = no
				is_heir = no
			}
			kill_leader = { show_notification = no }
		}
	}
}

# sets up necessary event_targets:
# event_target:potential_owner = from
# event_target:former_owner = fromfrom
# event_target:original_species = fromfrom.owner_species
# event_target:storage_owner = country, pre-FTL leader storage
# event_target:variable_storage = country, pre-FTL leader variable storage
# this = planet (after new owner set)
# from = country (new owner)
# fromfrom = country (former owner, if any)
prepare_for_primitive_planet_transferred = {
	optimize_memory
	from = { save_event_target_as = potential_owner }
	fromfrom = {
		save_event_target_as = former_owner
		owner_species = { save_event_target_as = original_species }
	}
	# acquire leader and variable storage
	random_country = {
		limit = {
			has_country_flag = former_owner@fromfrom
			has_country_flag = potential_owner@from
		}
		save_event_target_as = storage_owner
		save_event_target_as = variable_storage
	}
}

# this = leader
# event_target:potential_owner = country for whom the leader is being stored
# event_target:storage_owner = country in which to store leaders
transfer_leader_to_storage = {
	optimize_memory
	if = {
		limit = { owner = { is_hive_empire = yes } }
		set_leader_flag = former_owner_hive
	}
	else_if = {
		limit = { owner = { is_machine_empire = yes } }
		set_leader_flag = former_owner_machine
	}
	set_leader_flag = stored_leader
	set_leader_flag = former_owner@owner
	set_leader_flag = potential_owner@event_target:potential_owner
	unassign_leader = this
	set_owner = event_target:storage_owner
	# intentionally does not fire on_leader_owner_changed
}

# this = leader
# event_target:potential_owner = country to become the new owner and for which to set species rights
take_ownership_of_leader = {
	optimize_memory
	if = {
		limit = { has_leader_flag = is_in_recruit_window }
		remove_leader_flag = is_in_recruit_window
	}
	if = {
		limit = { has_leader_flag = stored_leader }
		remove_leader_flag = stored_leader
	}
	set_owner = event_target:potential_owner
	fire_on_action = { on_action = on_leader_owner_changed }
}

# this = leader
# event_target:potential_owner = country to become the new owner and for which to set species rights
ensure_species_rights_and_take_ownership_of_leader = {
	optimize_memory
	if = {
		limit = {
			is_civilian_leader = yes
			can_be_civilian_leaders_species = no
			is_eligible_for_policy_full_citizenship_species = yes
		}
		set_full_citizenship_species = yes
	}
	else_if = {
		limit = {
			is_military_leader = yes
			can_be_military_leaders_species = no
			is_eligible_for_policy_full_military_service_species = yes
		}
		set_full_military_service_species = yes
	}
	set_minimum_living_standard_species = yes
	unassign_leader = this
	try_adjust_background = yes
	take_ownership_of_leader = yes
	try_assign_retained_leader_to_former_assignment = yes
}

# this = something with species
# event_target:potential_owner = country to set citizenship
set_full_citizenship_species = {
	optimize_memory
	species= {
		if = {
			limit = {
				event_target:potential_owner = { is_machine_empire = yes }
				NOR = {
					has_citizenship_type = {
						country = event_target:potential_owner
						type = citizenship_full_machine
					}
					has_citizenship_type = {
						country = event_target:potential_owner
						type = citizenship_assimilation
					}
				}
			}
			set_citizenship_type = {
				country = event_target:potential_owner
				type = citizenship_full_machine
				cooldown = no
			}
		}
		else_if = {
			limit = {
				NOR = {
					has_citizenship_type = {
						country = event_target:potential_owner
						type = citizenship_full
					}
					has_citizenship_type = {
						country = event_target:potential_owner
						type = citizenship_assimilation
					}
				}
			}
			set_citizenship_type = {
				country = event_target:potential_owner
				type = citizenship_full
				cooldown = no
			}
			if = {
				limit = {
					event_target:potential_owner = { has_valid_civic = civic_citizen_service }
					NOT = {
						has_military_service_type = {
							country = event_target:potential_owner
							type = military_service_full
						}
					}
				}
				set_military_service_type = {
					country = event_target:potential_owner
					type = military_service_full
					cooldown = no
				}
			}
		}
	}
}

# this = something with species
# event_target:potential_owner = country to set military service
set_full_military_service_species = {
	optimize_memory
	species= {
		if = {
			limit = {
				NOT = {
					has_military_service_type = {
						country = event_target:potential_owner
						type = military_service_full
					}
				}
			}
			if = {
				limit = {
					event_target:potential_owner = { is_machine_empire = yes }
					NOR = {
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_full_machine
						}
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
					}
				}
				set_citizenship_type = {
					country = event_target:potential_owner
					type = citizenship_full_machine
					cooldown = no
				}
			}
			else_if = {
				limit = {
					event_target:potential_owner = { is_hive_empire = yes }
					NOR = {
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_full
						}
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
					}
				}
				set_citizenship_type = {
					country = event_target:potential_owner
					type = citizenship_full
					cooldown = no
				}
			}
			else_if = {
				limit = {
					event_target:potential_owner = { has_valid_civic = civic_citizen_service }
					NOR = {
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_full
						}
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
					}
				}
				set_citizenship_type = {
					country = event_target:potential_owner
					type = citizenship_full
					cooldown = no
				}
			}
			else_if = {
				limit = {
					NOR = {
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_full
						}
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_limited
						}
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
						AND = {
							has_battle_thrall_military_leaders_active = yes
							has_citizenship_type = {
								country = event_target:potential_owner
								type = citizenship_slavery
							}
							has_slavery_type = {
								country = event_target:potential_owner
								type = slavery_military
							}
						}
					}
				}
				set_citizenship_type = {
					country = event_target:potential_owner
					type = citizenship_limited
					cooldown = no
				}
			}
			set_military_service_type = {
				country = event_target:potential_owner
				type = military_service_full
				cooldown = no
			}
		}
	}
}

# this = something with species
# event_target:potential_owner = country to ensure minimum standard of living
set_minimum_living_standard_species = {
	optimize_memory
	species= {
		if = {
			limit = {
				event_target:potential_owner = {
					OR = {
						is_machine_empire = yes
						is_hive_empire = yes
					}
				}
				OR = {
					has_citizenship_type = {
						country = event_target:potential_owner
						type = citizenship_full
					}
					has_citizenship_type = {
						country = event_target:potential_owner
						type = citizenship_full_machine
					}
				}
			}
			set_living_standard = {
				country = event_target:potential_owner
				type = living_standard_hive_mind
			}
		}
		else_if = {
			limit = {
				event_target:potential_owner = { is_regular_empire = yes }
				NOR = {
					has_citizenship_type = {
						country = event_target:potential_owner
						type = citizenship_assimilation
					}
					AND = {
						has_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_purge
						}
						has_living_standard = {
							country = event_target:potential_owner
							type = living_standard_none
						}
						has_purge_type = {
							country = event_target:potential_owner
							type = purge_necrophage
						}
					}
					AND = {
						is_robotic = yes
						event_target:potential_owner = { has_full_ai_rights = no }
					}
				}
			}
			if = {
				limit = { event_target:potential_owner = { has_valid_civic = civic_shared_burden } }
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_shared_burden
					cooldown = no
				}
			}
			else_if = {
				limit = { event_target:potential_owner = { has_valid_civic = civic_dystopian_society } }
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_dystopian_society
					cooldown = no
				}
			}
			else_if = {
				limit = { event_target:potential_owner = { is_pleasure_seeker = yes } }
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_decadent
					cooldown = no
				}
			}
			else_if = {
				limit = { event_target:potential_owner = { is_materialist = yes } }
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_academic_privilege
					cooldown = no
				}
			}
			else_if = {
				limit = { event_target:potential_owner = { is_authoritarian = yes } }
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_stratified
					cooldown = no
				}
			}
			else_if = {
				limit = {
					has_citizenship_type = {
						country = event_target:potential_owner
						type = citizenship_full
					}
				}
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_normal
					cooldown = no
				}
			}
			else = {
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_subsistence
					cooldown = no
				}
			}
		}
	}
}

# this = species
# event_target:potential_owner = country doing the assimilating
set_citizenship_assimilation_and_living_standard_synthetic = {
	optimize_memory
	if = {
		limit = {
			NOT = { has_species_flag = living_standard_set@event_target:potential_owner }
			event_target:potential_owner = { is_potential_for_synthetic_assimilation_country = yes }
		}
		set_citizenship_type = {
			country = event_target:potential_owner
			type = citizenship_assimilation
			cooldown = no
		}
		set_living_standard = {
			country = event_target:potential_owner
			type = living_standard_tech_assimilation
			cooldown = no
		}
		set_timed_species_flag = {
			flag = living_standard_set@event_target:potential_owner
			days = 1
		}
	}
}

# this = species
# event_target:potential_owner = country doing the assimilating
set_citizenship_assimilation_and_living_standard_unmachine = {
	optimize_memory
	if = {
		limit = {
			NOT = { has_species_flag = living_standard_set@event_target:potential_owner }
			event_target:potential_owner = { is_potential_for_unmachine_assimilation_country = yes }
		}
		set_citizenship_type = {
			country = event_target:potential_owner
			type = citizenship_assimilation
			cooldown = no
		}
		set_living_standard = {
			country = event_target:potential_owner
			type = living_standard_deassimilation_machine
			cooldown = no
		}
		set_timed_species_flag = {
			flag = living_standard_set@event_target:potential_owner
			days = 1
		}
	}
}

# this = species
# event_target:potential_owner = country doing the assimilating
set_citizenship_assimilation_and_living_standard_cyborg = {
	optimize_memory
	if = {
		limit = {
			NOT = { has_species_flag = living_standard_set@event_target:potential_owner }
			event_target:potential_owner = { is_potential_for_cyborg_assimilation_country = yes }
		}
		if = {
			limit = {
				event_target:potential_owner = {
					OR = {
						has_valid_civic = civic_machine_assimilator
						is_regular_hive_empire = yes
					}
				}
			}
			set_citizenship_type = {
				country = event_target:potential_owner
				type = citizenship_assimilation
				cooldown = no
			}
			if = {
				limit = { has_psionic_species_trait = no }
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_cyborg_ego_assimilation
					cooldown = no
				}
			}
			else = {
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_cyborg_ego_assimilation_psionic
					cooldown = no
				}
			}
			set_timed_species_flag = {
				flag = living_standard_set@event_target:potential_owner
				days = 1
			}
		}
		else_if = {
			limit = { event_target:potential_owner = { is_regular_empire = yes } }
			set_citizenship_type = {
				country = event_target:potential_owner
				type = citizenship_assimilation
				cooldown = no
			}
			if = {
				limit = { has_psionic_species_trait = no }
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_cyborg_assimilation
					cooldown = no
				}
			}
			else = {
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_cyborg_assimilation_psionic
					cooldown = no
				}
			}
			set_timed_species_flag = {
				flag = living_standard_set@event_target:potential_owner
				days = 1
			}
		}
	}
}

# this = species
# event_target:potential_owner = country doing the assimilating
set_citizenship_assimilation_and_living_standard_uncyborg = {
	optimize_memory
	if = {
		limit = {
			NOT = { has_species_flag = living_standard_set@event_target:potential_owner }
			event_target:potential_owner = { is_potential_for_uncyborg_assimilation_country = yes }
		}
		set_citizenship_type = {
			country = event_target:potential_owner
			type = citizenship_assimilation
			cooldown = no
		}
		set_living_standard = {
			country = event_target:potential_owner
			type = living_standard_deassimilation_cyborg
			cooldown = no
		}
		set_timed_species_flag = {
			flag = living_standard_set@event_target:potential_owner
			days = 1
		}
	}
}

# this = species
# event_target:potential_owner = country doing the assimilating
set_citizenship_assimilation_and_living_standard_psionic = {
	optimize_memory
	if = {
		limit = {
			NOT = { has_species_flag = living_standard_set@event_target:potential_owner }
			event_target:potential_owner = { is_potential_for_psionic_assimilation_country = yes }
		}
		set_citizenship_type = {
			country = event_target:potential_owner
			type = citizenship_assimilation
			cooldown = no
		}
		if = {
			limit = { NOT = { has_trait = trait_cybernetic } }
			set_living_standard = {
				country = event_target:potential_owner
				type = living_standard_psi_assimilation
				cooldown = no
			}
		}
		else = {
			set_living_standard = {
				country = event_target:potential_owner
				type = living_standard_psi_assimilation_cyborg
				cooldown = no
			}
		}
		set_timed_species_flag = {
			flag = living_standard_set@event_target:potential_owner
			days = 1
		}
	}
}

# this = species
# event_target:potential_owner = country doing the assimilating
set_citizenship_assimilation_and_living_standard_genetic = {
	optimize_memory
	if = {
		limit = {
			NOT = { has_species_flag = living_standard_set@event_target:potential_owner }
			event_target:potential_owner = { is_potential_for_genetic_assimilation_country = yes }
		}
		if = {
			limit = { event_target:potential_owner = { is_regular_empire = yes } }
			set_citizenship_type = {
				country = event_target:potential_owner
				type = citizenship_assimilation
				cooldown = no
			}
			set_living_standard = {
				country = event_target:potential_owner
				type = living_standard_deassimilation
				cooldown = no
			}
			set_timed_species_flag = {
				flag = living_standard_set@event_target:potential_owner
				days = 1
			}
		}
		else_if = {
			limit = { event_target:potential_owner = { is_regular_hive_empire = yes } }
			set_citizenship_type = {
				country = event_target:potential_owner
				type = citizenship_assimilation
				cooldown = no
			}
			if = {
				limit = { has_psionic_species_trait = no }
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_ego_assimilation
					cooldown = no
				}
			}
			else = {
				set_living_standard = {
					country = event_target:potential_owner
					type = living_standard_ego_assimilation_psionic
					cooldown = no
				}
			}
			set_timed_species_flag = {
				flag = living_standard_set@event_target:potential_owner
				days = 1
			}
		}
	}
}

# this = leader
try_process_gestalt_ruler = {
	optimize_memory
	if = {
		limit = {
			exists = owner
			owner = { is_gestalt = yes }
		}
		set_leader_flag = former_gestalt_ruler
		remove_trait = leader_trait_ruler_machine_intelligence
		remove_trait = leader_trait_ruler_hive_mind
	}
}

# this = leader
# event_target:potential_owner = the country scope that will potentially become the owner of the leader
# event_target:variable_storage = a scope that has these variables:
# * leader_accumulator
# * leader_organic_accumulator
# * leader_hive_accumulator
# * leader_robotic_accumulator
# * leader_necrophagable_accumulator
# * leader_same_species_accumulator
# * leader_not_same_species_accumulator
# * leader_transferable_accumulator
# * leader_transferable_or_assimilatable_accumulator
# * leader_assimilation_cyborg_allowable_accumulator
# * leader_assimilation_cyborg_allowable_accumulator_double
# * leader_assimilation_uncyborg_allowable_accumulator
# * leader_assimilation_synthetic_allowable_accumulator
# * leader_assimilation_unmachine_allowable_accumulator
# * leader_assimilation_psionic_allowable_accumulator
# * leader_assimilation_genetic_allowable_accumulator
# * leader_aquatic_accumulator
accumulate_leader = {
	optimize_memory
	tag_leader_for_reassignment = yes
	if = {
		limit = { is_robotic_species_lenient = yes }
		event_target:variable_storage = {
			change_variable = {
				which = leader_robotic_accumulator
				value = 1
			}
		}
	}
	else = {
		event_target:variable_storage = {
			change_variable = {
				which = leader_organic_accumulator
				value = 1
			}
		}
	}
	if = {
		limit = { is_hive_species = yes }
		event_target:variable_storage = {
			change_variable = {
				which = leader_hive_accumulator
				value = 1
			}
		}
	}
	if = {
		limit = {
			species = {
				is_robotic = no
				is_sapient = yes
				NOR = {
					is_same_species = event_target:potential_owner.owner_species
					AND = {
						has_slavery_type = {
							type = slavery_livestock
							country = event_target:potential_owner
						}
						event_target:potential_owner = { is_hive_empire = no }
					}
				}
				OR = {
					species_has_happiness_with_owner = event_target:potential_owner
					has_trait = trait_hive_mind # hive Pops are necrophagable, so leaders are too
				}
			}
		}
		event_target:variable_storage = {
			change_variable = {
				which = leader_necrophagable_accumulator
				value = 1
			}
		}
	}
	if = {
		limit = { is_same_species = event_target:potential_owner.owner_species }
		event_target:variable_storage = {
			change_variable = {
				which = leader_same_species_accumulator
				value = 1
			}
		}
	}
	else = {
		event_target:variable_storage = {
			change_variable = {
				which = leader_not_same_species_accumulator
				value = 1
			}
		}
	}
	if = {
		limit = { is_allow_transfer_without_assimilation = yes }
		event_target:variable_storage = {
			change_variable = {
				which = leader_transferable_accumulator
				value = 1
			}
			change_variable = {
				which = leader_transferable_or_assimilatable_accumulator
				value = 1
			}
		}
	}
	# else_if helps skip duplicate checks for leaders that don't need assimilation
	else_if = {
		limit = { is_allow_transfer_with_assimilation = yes }
		event_target:variable_storage = {
			change_variable = {
				which = leader_transferable_or_assimilatable_accumulator
				value = 1
			}
		}
	}
	# individual counts needed due to support for multi-assimilation
	if = {
		limit = {
			OR = {
				event_target:potential_owner = { is_regular_empire = no }
				AND = {
					is_smart_enough_for_leadership_species = yes
					is_regular_empire_ethics_allowable_leader_species = yes
				}
			}
		}
		if = {
			limit = { is_potential_for_cyborg_assimilation = yes }
			event_target:variable_storage = {
				change_variable = {
					which = leader_assimilation_cyborg_allowable_accumulator
					value = 1
				}
				change_variable = {
					which = leader_assimilation_cyborg_allowable_accumulator_double
					value = 2
				}
			}
		}
		if = {
			limit = { is_potential_for_uncyborg_assimilation = yes }
			event_target:variable_storage = {
				change_variable = {
					which = leader_assimilation_uncyborg_allowable_accumulator
					value = 1
				}
			}
		}
		if = {
			limit = { is_potential_for_psionic_assimilation = yes }
			event_target:variable_storage = {
				change_variable = {
					which = leader_assimilation_psionic_allowable_accumulator
					value = 1
				}
			}
		}
		if = {
			limit = { is_potential_for_genetic_assimilation = yes }
			event_target:variable_storage = {
				change_variable = {
					which = leader_assimilation_genetic_allowable_accumulator
					value = 1
				}
			}
		}
	}
	if = {
		limit = { event_target:potential_owner = { allows_ai_leaders = yes } }
		if = {
			limit = { is_potential_for_synthetic_assimilation = yes }
			event_target:variable_storage = {
				change_variable = {
					which = leader_assimilation_synthetic_allowable_accumulator
					value = 1
				}
			}
		}
		if = {
			limit = { is_potential_for_unmachine_assimilation = yes }
			event_target:variable_storage = {
				change_variable = {
					which = leader_assimilation_unmachine_allowable_accumulator
					value = 1
				}
			}
		}
	}
	if = {
		limit = { is_aquatic_species = yes }
		event_target:variable_storage = {
			change_variable = {
				which = leader_aquatic_accumulator
				value = 1
			}
		}
	}
	event_target:variable_storage = {
		change_variable = {
			which = leader_accumulator
			value = 1
		}
	}
}

# this = leader
tag_leader_for_reassignment = {
	optimize_memory
	switch = {
		trigger = leader_class
		# it seems that governors have already been unassigned from their planets as integration completes
		governor = {
			if = {
				limit = { exists = planet }
				set_leader_flag = keep_leader_match_planet@this
				planet = { set_planet_flag = keep_leader_match_planet@prev }
			}
			else_if = {
				limit = { is_heir = yes }
				set_leader_flag = keep_leader_heir_match_planet@this
				owner.capital_scope = { set_planet_flag = keep_leader_heir_match_planet@prev }
			}
			else_if = {
				limit = { is_ruler = yes }
				set_leader_flag = keep_leader_ruler_match_planet@this
				owner.capital_scope = { set_planet_flag = keep_leader_ruler_match_planet@prev }
			}
		}
		scientist = {
			if = {
				limit = { exists = fleet }
				set_leader_flag = keep_leader_match_fleet@this
				fleet = { set_fleet_flag = keep_leader_match_fleet@prev }
			}
			# leaders no longer research specific areas
			# switch = {
			# 	trigger = is_researching_area
			# 	physics = { set_leader_flag = keep_leader_research_physics }
			# 	society = { set_leader_flag = keep_leader_research_society }
			# 	engineering = { set_leader_flag = keep_leader_research_engineering }
			# }
		}
		admiral = {
			if = {
				limit = { exists = fleet }
				set_leader_flag = keep_leader_match_fleet@this
				fleet = { set_fleet_flag = keep_leader_match_fleet@prev }
			}
		}
		# generals can't be reassigned because armies can't have their owners changed, and it's not possible to clone the transports before integration completes
		# it seems that generals have also already been unassigned from their planets as integration completes
		general = {
			if = {
				limit = { exists = fleet }
				set_leader_flag = keep_leader_match_transport_fleet@this
				fleet = { set_fleet_flag = keep_leader_match_transport_fleet@prev }
			}
			else_if = {
				limit = { exists = planet }
				set_leader_flag = keep_leader_match_planet@this
				planet = { set_planet_flag = keep_leader_match_planet@prev }
			}
			else_if = {
				limit = { is_heir = yes }
				set_leader_flag = keep_leader_heir_match_planet@this
				owner.capital_scope = { set_planet_flag = keep_leader_heir_match_planet@prev }
			}
			else_if = {
				limit = { is_ruler = yes }
				set_leader_flag = keep_leader_ruler_match_planet@this
				owner.capital_scope = { set_planet_flag = keep_leader_ruler_match_planet@prev }
			}
			owner = {
				random_owned_army = {
					limit = {
						exists = leader
						leader = { is_same_value = prevprev }
					}
					leader = { set_leader_flag = keep_leader_match_army@this }
					set_army_flag = keep_leader_match_army@leader
				}
			}
		}
	}
}

# this = leader
try_assign_retained_leader_to_former_assignment = {
	optimize_memory
	switch = {
		trigger = leader_class
		governor = {
			if = {
				limit = { has_leader_flag = keep_leader_match_planet@this }
				owner = {
					random_owned_planet = {
						limit = { has_planet_flag = keep_leader_match_planet@prevprev }
						assign_leader = prevprev
						log = "\\[PrevPrev.GetTitle] \\[PrevPrev.GetName] resumed governing \\[This.GetName]"
					}
				}
			}
		}
		scientist = {
			if = {
				limit = { has_leader_flag = keep_leader_match_fleet@this }
				owner = {
					random_controlled_fleet = {
						limit = {
							has_fleet_flag = keep_leader_match_fleet@prevprev
							NOT = { exists = leader }
						}
						assign_leader = prevprev
						log = "\\[PrevPrev.GetTitle] \\[PrevPrev.GetName] resumed command of science vessel \\[This.GetName]"
					}
				}
			}
		}
		admiral = {
			if = {
				limit = { has_leader_flag = keep_leader_match_fleet@this }
				owner = {
					random_controlled_fleet = {
						limit = {
							has_fleet_flag = keep_leader_match_fleet@prevprev
							NOT = { exists = leader }
						}
						assign_leader = prevprev
						log = "\\[PrevPrev.GetTitle] \\[PrevPrev.GetName] resumed command of fleet \\[This.GetName]"
					}
				}
			}
		}
		general = {
			if = {
				limit = { has_leader_flag = keep_leader_match_planet@this }
				owner = {
					random_owned_planet = {
						limit = { has_planet_flag = keep_leader_match_planet@prevprev }
						assign_leader = prevprev
						log = "\\[PrevPrev.GetTitle] \\[PrevPrev.GetName] resumed command of the planetary defenses on \\[This.GetName]"
					}
				}
			}
			# armies can't have their owners changed, an it's unclear how I could clone the transports before integration fires, so generals can't resume command of armies directly
			# if = {
			# 	limit = { has_leader_flag = keep_leader_match_transport_fleet@this }
			# 	owner = {
			# 		random_controlled_fleet = {
			# 			limit = {
			# 				has_fleet_flag = keep_leader_match_transport_fleet@prevprev
			# 				NOT = { exists = leader }
			# 			}
			# 			assign_leader = prevprev
			# 			log = "\\[PrevPrev.GetTitle] \\[PrevPrev.GetName] resumed command of transport fleet \\[This.GetName]"
			# 		}
			# 	}
			# }
			# else_if = {
			# 	limit = { has_leader_flag = keep_leader_match_army@this }
			# 	owner = {
			# 		random_owned_army = {
			# 			limit = {
			# 				has_army_flag = keep_leader_match_army@prevprev
			# 				NOT = { exists = leader }
			# 			}
			# 			assign_leader = prevprev
			# 			log = "\\[PrevPrev.GetTitle] \\[PrevPrev.GetName] resumed command of the army \\[This.GetName]"
			# 		}
			# 	}
			# }
		}
	}
}

# somewhat hacky workaround to spawn an army transport of a specific type with less repeated code, and also using localisation for the name
# this = fleet, to which the transport will be assigned
# ARMY_TYPE = army type to create
# event_target:source_ship = transport being duplicated
# event_target:source_army = army being duplicated
create_army_transport_parameterized = {
	optimize_memory
	if = {
		limit = { exists = event_target:source_army.species }
		create_army_transport = {
			species = event_target:source_army
			army_type = $ARMY_TYPE$
			effect = {
				set_name = {
					key = keep_leaders.source_ship_name
					variable_string = "\\[source_ship.GetName\\]"
				}
				last_created_army = {
					set_name = {
						key = keep_leaders.source_army_name
						variable_string = "\\[source_army.GetName\\]"
					}
				}
			}
		}
	}
	else = {
		create_army_transport = {
			army_type = $ARMY_TYPE$
			effect = {
				set_name = {
					key = keep_leaders.source_ship_name
					variable_string = "\\[source_ship.GetName\\]"
				}
				last_created_army = {
					set_name = {
						key = keep_leaders.source_army_name
						variable_string = "\\[source_army.GetName\\]"
					}
				}
			}
		}
	}
}

# set up a species for cybernetic assimilation (non-hive), saved as event_target:prepared_species
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
# event_target:potential_owner = country
klfis_prepare_cyborg_species = {
	optimize_memory
	if = {
		limit = { event_target:potential_owner = { is_hive_empire = no } }
		if = {
			limit = { has_assimilate_all_the_pops_active = no }
			modify_species = {
				species = event_target:prepared_species
				add_trait = trait_cybernetic
				add_traits_at_start_of_list = yes
				remove_trait = trait_self_modified
				remove_trait = trait_hive_mind
				remove_trait = trait_latent_psionic
				remove_trait = trait_psionic
				change_scoped_species = no
				effect = {
					save_event_target_as = prepared_species
				}
			}
		}
		else = {
			modify_species = {
				species = event_target:prepared_species
				add_trait = trait_cybernetic
				add_traits_at_start_of_list = yes
				remove_trait = trait_self_modified
				remove_trait = trait_hive_mind
				change_scoped_species = no
				effect = {
					save_event_target_as = prepared_species
				}
			}
		}
	}
	else = {
		modify_species = {
			species = event_target:prepared_species
			add_trait = trait_cybernetic
			add_trait = trait_hive_mind
			add_traits_at_start_of_list = yes
			remove_trait = trait_self_modified
			remove_trait = trait_latent_psionic
			remove_trait = trait_psionic
			change_scoped_species = no
			effect = {
				save_event_target_as = prepared_species
			}
		}
	}

}

# set up a species for hive assimilation, saved as event_target:prepared_species
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
klfis_prepare_hive_species = {
	optimize_memory
	modify_species = {
		species = event_target:prepared_species
		add_trait = trait_hive_mind
		add_traits_at_start_of_list = yes
		remove_trait = trait_self_modified
		remove_trait = trait_latent_psionic
		remove_trait = trait_psionic
		change_scoped_species = no
		effect = {
			save_event_target_as = prepared_species
		}
	}
}

# set up a species for hive deassimilation, saved as event_target:prepared_species
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
klfis_prepare_unhive_species = {
	optimize_memory
	modify_species = {
		species = event_target:prepared_species
		remove_trait = trait_self_modified
		remove_trait = trait_hive_mind
		change_scoped_species = no
		effect = {
			save_event_target_as = prepared_species
		}
	}
}

# set up a species for psionic assimilation, saved as event_target:prepared_species
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
klfis_prepare_psionic_species = {
	optimize_memory
	if = {
		limit = { has_assimilate_all_the_pops_active = no }
		modify_species = {
			species = event_target:prepared_species
			add_trait = trait_psionic
			add_traits_at_start_of_list = yes
			remove_trait = trait_self_modified
			remove_trait = trait_latent_psionic
			remove_trait = trait_cybernetic
			remove_trait = trait_cyborg_power_drills
			remove_trait = trait_cyborg_harvesters
			remove_trait = trait_cyborg_superconductive
			remove_trait = trait_cyborg_efficient_processors
			remove_trait = trait_cyborg_logic_engines
			remove_trait = trait_cyborg_loyalty_circuits
			remove_trait = trait_cyborg_double_jointed
			remove_trait = trait_cyborg_bulky
			remove_trait = trait_cyborg_enhanced_memory
			remove_trait = trait_cyborg_durable
			remove_trait = trait_cyborg_high_maintenance
			remove_trait = trait_cyborg_learning_algorithms
			remove_trait = trait_cyborg_power_intensive
			remove_trait = trait_cyborg_neural_limiters
			remove_trait = trait_cyborg_streamlined_protocols
			remove_trait = trait_cyborg_high_bandwidth
			remove_trait = trait_cyborg_trading_algorithms
			change_scoped_species = no
			effect = {
				save_event_target_as = prepared_species
			}
		}
	}
	else = {
		modify_species = {
			species = event_target:prepared_species
			add_trait = trait_psionic
			add_traits_at_start_of_list = yes
			remove_trait = trait_self_modified
			remove_trait = trait_latent_psionic
			change_scoped_species = no
			effect = {
				save_event_target_as = prepared_species
			}
		}
	}
}

# changes a gender's leader to match the norms for their species (possibly cloning and replacing them)
# this = leader, with new species
klfis_leader_match_gender_to_species = {
	optimize_memory
	species = {
		switch = {
			trigger = species_gender
			female = {
				prev = {
					if = {
						limit = { NOT = { gender = female } }
						set_gender = female
					}
				}
			}
			male = {
				prev = {
					if = {
						limit = { NOT = { gender = male } }
						set_gender = male
					}
				}
			}
			indeterminable = {
				prev = {
					if = {
						limit = { NOT = { gender = indeterminable } }
						set_gender = indeterminable
					}
				}
			}
			not_set = {
				prev = {
					if = {
						limit = {
							klfis_species_class_uses_gender = yes
							NOR = {
								gender = female
								gender = male
							}
						}
						random_list = {
							50 = { set_gender = female }
							50 = { set_gender = male }
						}
					}
				}
			}
		}
	}
}

# this = leader
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
# event_target:potential_owner = country
# assimilation_type_counter (variable) how many (if any) assimilation changes were applied
try_apply_cyborg_assimilation = {
	optimize_memory
	if = {
		limit = {
			event_target:prepared_species = { is_potential_for_cyborg_assimilation = yes }
			OR = {
				has_civic_organic_zealots_active = no
				event_target:potential_owner = {
					NOT = { has_country_flag = lost_robot_policy_war }
					is_valid_organic_zealots = no
					NAND = {
						is_subject = yes
						overlord = { is_valid_organic_zealots = yes }
					}
				}
			}
		}
		species = { set_citizenship_assimilation_and_living_standard_cyborg = yes }
		klfis_prepare_cyborg_species = yes
		set_timed_leader_flag = {
			flag = cybernetic_assimilation
			days = 1
		}
		change_variable = {
			which = assimilation_type_counter
			value = 1
		}
	}
}

# this = leader
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
# event_target:potential_owner = country
# assimilation_type_counter (variable) how many (if any) assimilation changes were applied
try_apply_synthetic_assimilation = {
	optimize_memory
	if = {
		limit = { event_target:prepared_species = { is_potential_for_synthetic_assimilation = yes } }
		# if you convert hive to synths, you lose the secret hive magic
		if = {
			limit = {
				has_leader_flag = former_gestalt_ruler
				is_hive_species = yes # intentionally checks the leader's original species
			}
			remove_leader_flag = former_gestalt_ruler
		}
		species = { set_citizenship_assimilation_and_living_standard_synthetic = yes }
		event_target:potential_owner.owner_species = { save_event_target_as = prepared_species }
		set_timed_leader_flag = {
			flag = synthetic_assimilation
			days = 1
		}
		change_variable = {
			which = assimilation_type_counter
			value = 1
		}
	}
}

# this = leader
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
# event_target:potential_owner = country
# assimilation_type_counter (variable) how many (if any) assimilation changes were applied
try_apply_unmachine_assimilation = {
	optimize_memory
	if = {
		limit = { event_target:prepared_species = { is_potential_for_unmachine_assimilation = yes } }
		species = { set_citizenship_assimilation_and_living_standard_unmachine = yes }
		# weird scoping is to set prev and this as expected by the effect
		event_target:potential_owner = { event_target:prepared_species = { dm_prepare_machine_to_mechanical_species = yes } }
		set_timed_leader_flag = {
			flag = unmachine_assimilation
			days = 1
		}
		change_variable = {
			which = assimilation_type_counter
			value = 1
		}
	}
}

# this = leader
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
# event_target:potential_owner = country
# assimilation_type_counter (variable) how many (if any) assimilation changes were applied
try_apply_uncyborg_assimilation = {
	optimize_memory
	if = {
		limit = { event_target:prepared_species = { is_potential_for_uncyborg_assimilation = yes } }
		species = { set_citizenship_assimilation_and_living_standard_uncyborg = yes }
		# weird scoping is to set prev and this as expected by the effect
		event_target:potential_owner = { event_target:prepared_species = { coz_prepare_uncyborg_species = yes } }
		set_timed_leader_flag = {
			flag = uncybernetic_assimilation
			days = 1
		}
		change_variable = {
			which = assimilation_type_counter
			value = 1
		}
	}
}

# this = leader
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
# event_target:potential_owner = country
# assimilation_type_counter (variable) how many (if any) assimilation changes were applied
try_apply_psionic_assimilation = {
	optimize_memory
	if = {
		limit = { event_target:prepared_species = { is_potential_for_psionic_assimilation = yes } }
		species = { set_citizenship_assimilation_and_living_standard_psionic = yes }
		klfis_prepare_psionic_species = yes
		set_timed_leader_flag = {
			flag = psionic_assimilation
			days = 1
		}
		change_variable = {
			which = assimilation_type_counter
			value = 1
		}
	}
}

# this = leader
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
# event_target:potential_owner = country
# assimilation_type_counter (variable) how many (if any) assimilation changes were applied
try_apply_genetic_assimilation = {
	optimize_memory
	if = {
		limit = { event_target:prepared_species = { is_potential_for_genetic_assimilation = yes } }
		species = { set_citizenship_assimilation_and_living_standard_genetic = yes }
		if = {
			limit = { is_hive_species = yes }
			klfis_prepare_unhive_species = yes
		}
		else = {
			klfis_prepare_hive_species = yes
			if = {
				limit = { is_gestalt = no }
				change_background_ethic = ethic_gestalt_consciousness
			}
		}
		set_timed_leader_flag = {
			flag = genetic_assimilation
			days = 1
		}
		change_variable = {
			which = assimilation_type_counter
			value = 1
		}
	}
}

# this = leader
# event_target:potential_owner = country to become the new owner
# event_target:prepared_species = the species being prepared (possibly with one or more changes from previous assimilations)
# assimilation_type_counter (variable) how many (if any) assimilation changes were applied
complete_assimilation_and_take_ownership_of_leader = {
	optimize_memory
	if = {
		limit = {
			check_variable = {
				which = assimilation_type_counter
				value > 0
			}
		}
		change_species = event_target:prepared_species
		fire_on_action = {
			on_action = on_leader_species_changed
			scopes = { from = event_target:former_species }
		}
		ensure_species_rights_and_take_ownership_of_leader = yes
	}
	else_if = {
		limit = { is_allow_transfer_without_assimilation = yes }
		ensure_species_rights_and_take_ownership_of_leader = yes
	}
	clear_variable = assimilation_type_counter
}

# change a leader's background ethic (randomize if formerly gestalt or convert to gestalt, if appropriate)
# this = leader
# event_target:potential_owner = country to become the new owner and for which to set species rights
try_adjust_background = {
	optimize_memory
	if = {
		limit = {
			NOR = {
				has_leader_flag = renowned_leader
				has_leader_flag = legendary_leader
			}
		}
		if = {
			limit = {
				is_gestalt = yes
				event_target:potential_owner = { is_gestalt = no }
			}
			randomize_background_ethic = yes
			reroll_random = yes
		}
		else_if = {
			limit = {
				is_gestalt = no
				event_target:potential_owner = {
					is_gestalt = yes
					NAND = {
						has_valid_civic = civic_machine_servitor
						prev = { is_robotic_species = no }
					}
				}
			}
			change_background_ethic = ethic_gestalt_consciousness
		}
		if = {
			limit = {
				is_gestalt = no
				NOT = { has_background_job = yes } # this can't be set to no or unemployed...
			}
			# intentionally does not have the same code as paragon_2.2125 or reuse the set_random_CLASS_background_effect effects
			if = {
				limit = { has_leader_flag = former_ruler }
				if = {
					limit = { has_leader_flag = former_owner_hive }
					change_background_job = hive_mind
				}
				else_if = {
					limit = { has_leader_flag = former_owner_machine }
					change_background_job = machine_intelligence
				}
				else = {
					change_background_job = government_employee
				}
			}
			else = {
				switch = {
					trigger = leader_class
					governor = {
						if = {
							limit = { has_leader_flag = former_owner_hive }
							change_background_job = synapse_drone
						}
						else_if = {
							limit = { has_leader_flag = former_owner_machine }
							random_list = {
								2 = { change_background_job = coordinator }
								1 = { change_background_job = evaluator }
							}
						}
						else = {
							random_list = {
								2 = { change_background_job = politician }
								1 = { change_background_job = bureaucrat }
							}
						}
					}
					scientist = {
						if = {
							limit = { has_leader_flag = former_owner_hive }
							random_list = {
								2 = { change_background_job = brain_drone }
								1 = { change_background_job = archaeo_drone }
							}
						}
						else_if = {
							limit = { has_leader_flag = former_owner_machine }
							random_list = {
								2 = { change_background_job = calculator }
								1 = { change_background_job = archaeo_unit }
							}
						}
						else = {
							random_list = {
								3 = { change_background_job = head_researcher }
								1 = { change_background_job = researcher }
								1 = { change_background_job = archaeoengineers }
							}
						}
					}
					admiral = {
						if = {
							limit = {
								OR = {
									has_leader_flag = former_owner_hive
									has_leader_flag = former_owner_machine
								}
							}
							random_list = {
								1 = { change_background_job = warrior_drone }
								1 = { change_background_job = patrol_drone }
							}
						}
						else = {
							set_random_admiral_background_effect = yes
						}
					}
					general = {
						if = {
							limit = {
								OR = {
									has_leader_flag = former_owner_hive
									has_leader_flag = former_owner_machine
								}
							}
							random_list = {
								1 = { change_background_job = warrior_drone }
								1 = { change_background_job = patrol_drone }
							}
						}
						else = {
							random_list = {
								1 = { change_background_job = special_operations_commander }
								1 = { change_background_job = commanding_officer }
								1 = { change_background_job = chief_supply_officer }
								1 = { change_background_job = intelligence_officer }
								1 = { change_background_job = chief_security_officer }
								1 = { change_background_job = enforcer }
								1 = { change_background_job = soldier }
							}
						}
					}
				}
				reroll_random = yes
			}
		}
	}
	if = {
		limit = { has_leader_flag = former_owner_hive }
		remove_leader_flag = former_owner_hive
	}
	if = {
		limit = { has_leader_flag = former_owner_machine }
		remove_leader_flag = former_owner_machine
	}
}

# randomize the leader's background ethic, weighted based on the ethos of their owner
# this = leader
# event_target:potential_owner = country to become the new owner
randomize_background_ethic = {
	optimize_memory
	random_list = {
		4 = {
			modifier = {
				factor = 2
				event_target:potential_owner = { has_ethic = ethic_militarist }
			}
			modifier = {
				factor = 4
				event_target:potential_owner = { has_ethic = ethic_fanatic_militarist }
			}
			modifier = {
				factor = 0.5
				event_target:potential_owner = { has_ethic = ethic_pacifist }
			}
			modifier = {
				factor = 0.25
				event_target:potential_owner = { has_ethic = ethic_fanatic_pacifist }
			}
			change_background_ethic = ethic_militarist
		}
		4 = {
			modifier = {
				factor = 2
				event_target:potential_owner = { has_ethic = ethic_xenophobe }
			}
			modifier = {
				factor = 4
				event_target:potential_owner = { has_ethic = ethic_fanatic_xenophobe }
			}
			modifier = {
				factor = 0.5
				event_target:potential_owner = { has_ethic = ethic_xenophile }
			}
			modifier = {
				factor = 0.25
				event_target:potential_owner = { has_ethic = ethic_fanatic_xenophile }
			}
			change_background_ethic = ethic_xenophobe
		}
		4 = {
			modifier = {
				factor = 2
				event_target:potential_owner = { has_ethic = ethic_egalitarian }
			}
			modifier = {
				factor = 4
				event_target:potential_owner = { has_ethic = ethic_fanatic_egalitarian }
			}
			modifier = {
				factor = 0.5
				event_target:potential_owner = { has_ethic = ethic_authoritarian }
			}
			modifier = {
				factor = 0.25
				event_target:potential_owner = { has_ethic = ethic_fanatic_authoritarian }
			}
			change_background_ethic = ethic_egalitarian
		}
		4 = {
			modifier = {
				factor = 2
				event_target:potential_owner = { has_ethic = ethic_materialist }
			}
			modifier = {
				factor = 4
				event_target:potential_owner = { has_ethic = ethic_fanatic_materialist }
			}
			modifier = {
				factor = 0.5
				event_target:potential_owner = { has_ethic = ethic_spiritualist }
			}
			modifier = {
				factor = 0.25
				event_target:potential_owner = { has_ethic = ethic_fanatic_spiritualist }
			}
			change_background_ethic = ethic_materialist
		}
		4 = {
			modifier = {
				factor = 2
				event_target:potential_owner = { has_ethic = ethic_pacifist }
			}
			modifier = {
				factor = 4
				event_target:potential_owner = { has_ethic = ethic_fanatic_pacifist }
			}
			modifier = {
				factor = 0.5
				event_target:potential_owner = { has_ethic = ethic_militarist }
			}
			modifier = {
				factor = 0.25
				event_target:potential_owner = { has_ethic = ethic_fanatic_militarist }
			}
			change_background_ethic = ethic_pacifist
		}
		4 = {
			modifier = {
				factor = 2
				event_target:potential_owner = { has_ethic = ethic_xenophile }
			}
			modifier = {
				factor = 4
				event_target:potential_owner = { has_ethic = ethic_fanatic_xenophile }
			}
			modifier = {
				factor = 0.5
				event_target:potential_owner = { has_ethic = ethic_xenophobe }
			}
			modifier = {
				factor = 0.25
				event_target:potential_owner = { has_ethic = ethic_fanatic_xenophobe }
			}
			change_background_ethic = ethic_xenophile
		}
		4 = {
			modifier = {
				factor = 2
				event_target:potential_owner = { has_ethic = ethic_authoritarian }
			}
			modifier = {
				factor = 4
				event_target:potential_owner = { has_ethic = ethic_fanatic_authoritarian }
			}
			modifier = {
				factor = 0.5
				event_target:potential_owner = { has_ethic = ethic_egalitarian }
			}
			modifier = {
				factor = 0.25
				event_target:potential_owner = { has_ethic = ethic_fanatic_egalitarian }
			}
			change_background_ethic = ethic_authoritarian
		}
		4 = {
			modifier = {
				factor = 2
				event_target:potential_owner = { has_ethic = ethic_spiritualist }
			}
			modifier = {
				factor = 4
				event_target:potential_owner = { has_ethic = ethic_fanatic_spiritualist }
			}
			modifier = {
				factor = 0.5
				event_target:potential_owner = { has_ethic = ethic_materialist }
			}
			modifier = {
				factor = 0.25
				event_target:potential_owner = { has_ethic = ethic_fanatic_materialist }
			}
			change_background_ethic = ethic_spiritualist
		}
	}
}

# this = any
# event_target:storage_owner = country in which leaders are stored
# event_target:potential_owner = country to which the leaders would transfer
choose_transfer_representative_leader = {
	optimize_memory
	event_target:storage_owner = {
		ordered_owned_leader = {
			limit = { is_eligible_transfer_leader_from_storage = yes }
			position = 0
			order_by = value:transfer_representative_leader_weight
			set_leader_flag = is_in_recruit_window
			save_event_target_as = transfer_representative
		}
	}
}

# this = leader
# $RETAIN_COVER$ = bool, whether the leader's portrait should be swapped to match the pre-FTL species (default = no)
# event_target:original_species = fromfrom.owner_species
# event_target:potential_owner = country to become the new owner and for which to set species rights
prepare_to_retain_infiltration_leader = {
	optimize_memory
	set_timed_leader_flag = {
		flag = force_gender_match_species
		days = 1
	}
	change_species = event_target:potential_owner
	fire_on_action = {
		on_action = on_leader_species_changed
		scopes = { from = event_target:original_species }
	}
	[[RETAIN_COVER] change_leader_portrait = event_target:original_species ]
	try_adjust_background = yes
}

# unexiling implicitly sets the owner to prev, since it is the owner of the fake fleet
# this = leader
# prev = country
klfis_unexile_leader = {
	optimize_memory
	create_fleet = {
		name = "unexile leader"
		effect = {
			set_owner = prevprev
			set_leader = prev
			save_event_target_as = unexile_fleet
		}
	}
	delete_fleet = {
		target = event_target:unexile_fleet
		kill_leader = no
		destroy_template = yes
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
retain_leaders_same_species_effect = {
	optimize_memory
	custom_tooltip_with_params = {
		description = keep_leaders.1.tooltip
		description_parameters = {
			VALUE = "\\[variable_storage.leader_same_species_accumulator]"
			TOTAL = "\\[variable_storage.leader_accumulator]"
		}
	}
	klfis_try_generate_rewards_fanatic_purifiers = yes
	klfis_try_generate_rewards_hive_devouring_swarm = yes
	hidden_effect = {
		country_event = {
			id = keep_leaders.12
			scopes = { from = event_target:storage_owner }
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
retain_leaders_organic_only_effect = {
	optimize_memory
	custom_tooltip_with_params = {
		description = keep_leaders.1.tooltip
		description_parameters = {
			VALUE = "\\[variable_storage.leader_organic_accumulator]"
			TOTAL = "\\[variable_storage.leader_accumulator]"
		}
	}
	klfis_try_generate_rewards_organic_zealots = yes
	hidden_effect = {
		country_event = {
			id = keep_leaders.11
			scopes = { from = event_target:storage_owner }
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
retain_leaders_robotic_only_effect = {
	optimize_memory
	custom_tooltip_with_params = {
		description = keep_leaders.1.tooltip
		description_parameters = {
			VALUE = "\\[variable_storage.leader_robotic_accumulator]"
			TOTAL = "\\[variable_storage.leader_accumulator]"
		}
	}
	klfis_try_generate_rewards_machine_terminator = yes
	hidden_effect = {
		country_event = {
			id = keep_leaders.10
			scopes = { from = event_target:storage_owner }
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
retain_leaders_hive_only_effect = {
	optimize_memory
	custom_tooltip_with_params = {
		description = keep_leaders.1.tooltip
		description_parameters = {
			VALUE = "\\[variable_storage.leader_hive_accumulator]"
			TOTAL = "\\[variable_storage.leader_accumulator]"
		}
	}
	hidden_effect = {
		country_event = {
			id = keep_leaders.14
			scopes = { from = event_target:storage_owner }
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
retain_leaders_all_non_assimilation_effect = {
	optimize_memory
	custom_tooltip_with_params = {
		description = keep_leaders.1.tooltip
		description_parameters = {
			VALUE = "\\[variable_storage.leader_transferable_accumulator]"
			TOTAL = "\\[variable_storage.leader_accumulator]"
		}
	}
	hidden_effect = {
		country_event = {
			id = keep_leaders.15
			scopes = { from = event_target:storage_owner }
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
klfis_try_generate_rewards_fanatic_purifiers = {
	optimize_memory
	if = {
		limit = { has_valid_civic = civic_fanatic_purifiers }
		add_resource = {
			unity = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_not_same_species_accumulator
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
klfis_try_generate_rewards_hive_devouring_swarm = {
	optimize_memory
	if = {
		limit = { has_valid_civic = civic_hive_devouring_swarm }
		add_resource = {
			society_research = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_organic_accumulator
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
klfis_try_generate_rewards_organic_zealots = {
	optimize_memory
	if = {
		limit = { is_valid_organic_zealots = yes }
		add_resource = {
			unity = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_robotic_accumulator
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
klfis_try_generate_rewards_machine_assimilator = {
	optimize_memory
	if = {
		limit = { has_valid_civic = civic_machine_assimilator }
		if = {
			limit = { NOT = { has_active_tradition = tr_cybernetics_assimilator_adopt } }
			add_resource = {
				unity = @keep_leaders_civic_reward_base
				society_research = @keep_leaders_civic_reward_base
				mult = event_target:variable_storage.leader_assimilation_cyborg_allowable_accumulator
			}
		}
		else = {
			add_resource = {
				unity = @keep_leaders_civic_reward_base
				society_research = @keep_leaders_civic_reward_base
				engineering_research = @keep_leaders_civic_reward_base
				mult = event_target:variable_storage.leader_assimilation_cyborg_allowable_accumulator_double
			}
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
klfis_try_generate_rewards_machine_terminator = {
	optimize_memory
	if = {
		limit = { has_valid_civic = civic_machine_terminator }
		add_resource = {
			unity = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_organic_accumulator
		}
	}
}

# this = country, which will become the owner the leaders
# event_target:variable_storage = a scope with the leader-count-related variables (see effects create_leader_storage_and_transfer_leaders and accumulate_leader)
klfis_try_generate_rewards_origin_necrophage = {
	optimize_memory
	if = {
		limit = {
			klfis_is_necrophage_empire = yes
			OR = {
				has_active_tradition = tr_harmony_unity_of_self
				has_active_tradition = tr_synchronicity_unity_of_mind
			}
		}
		add_resource = {
			unity = @keep_leaders_civic_reward_base
			mult = event_target:variable_storage.leader_necrophagable_accumulator
		}
	}
}

# this = leader
create_message_leader_recruited_with_appropriate_catch_phrase = {
	optimize_memory
	if = {
		limit = {
			NOR = {
				has_leader_flag = legendary_leader
				has_leader_flag = renowned_leader
				has_leader_flag = klfis_suppress_ethic_class_catch_phrase # tag your leader(s) with this if you set your own custom catch-phrases
			}
		}
		switch = {
			trigger = has_ethic
			ethic_authoritarian = { create_message_leader_recruited_with_ethic_appropriate_catch_phrase = { ETHIC = authoritarian } }
			ethic_egalitarian = { create_message_leader_recruited_with_ethic_appropriate_catch_phrase = { ETHIC = egalitarian } }
			ethic_militarist = { create_message_leader_recruited_with_ethic_appropriate_catch_phrase = { ETHIC = militarist } }
			ethic_pacifist = { create_message_leader_recruited_with_ethic_appropriate_catch_phrase = { ETHIC = pacifist } }
			ethic_spiritualist = { create_message_leader_recruited_with_ethic_appropriate_catch_phrase = { ETHIC = spiritualist } }
			ethic_materialist = { create_message_leader_recruited_with_ethic_appropriate_catch_phrase = { ETHIC = materialist } }
			ethic_xenophile = { create_message_leader_recruited_with_ethic_appropriate_catch_phrase = { ETHIC = xenophile } }
			ethic_xenophobe = { create_message_leader_recruited_with_ethic_appropriate_catch_phrase = { ETHIC = xenophobe } }
			default = { create_message_leader_recruited_with_default_catch_phrase = yes }
		}
	}
	else = {
		create_message_leader_recruited_with_default_catch_phrase = yes
	}
}

# this = leader, to be cloned
# $ETHIC$ = string, the leader's non-gestalt ethic
create_message_leader_recruited_with_ethic_appropriate_catch_phrase = {
	optimize_memory
	switch = {
		trigger = leader_class
		governor = {
			create_message_leader_recruited_with_ethic_and_class_appropriate_catch_phrase = {
				ETHIC = $ETHIC$
				CLASS = governor
			}
		}
		scientist = {
			create_message_leader_recruited_with_ethic_and_class_appropriate_catch_phrase = {
				ETHIC = $ETHIC$
				CLASS = scientist
			}
		}
		admiral = {
			create_message_leader_recruited_with_ethic_and_class_appropriate_catch_phrase = {
				ETHIC = $ETHIC$
				CLASS = admiral
			}
		}
		general = {
			create_message_leader_recruited_with_ethic_and_class_appropriate_catch_phrase = {
				ETHIC = $ETHIC$
				CLASS = general
			}
		}
		default = { create_message_leader_recruited_with_default_catch_phrase = yes }
	}
}

# this = leader
# $ETHIC$ = string, the leader's non-gestalt ethic
# $CLASS$ = string, the leader's class
create_message_leader_recruited_with_ethic_and_class_appropriate_catch_phrase = {
	optimize_memory
	create_message_leader_recruited_with_parameterized_catch_phrase = { CATCH_PHRASE = $ETHIC$_$CLASS$ }
}

# this = leader
create_message_leader_recruited_with_default_catch_phrase = {
	optimize_memory
	if = {
		limit = {
			OR = {
				has_leader_flag = event_leader
				has_leader_flag = renowned_leader
			}
		}
		create_message = {
			type = MESSAGE_RECRUITED_LEADER
			localization =  MESSAGE_RECRUITED_LEADER_DESC
			days = @toast_message_days
			target = this
			variable = {
				type = name
				localization = LEADER
				scope = this
			}
			variable = {
				key = border
				value = GFX_border_veteran
			}
		}
	}
	else_if = {
		limit = { has_leader_flag = legendary_leader }
		create_message = {
			type = MESSAGE_RECRUITED_LEADER
			localization =  MESSAGE_RECRUITED_LEADER_DESC
			days = @toast_message_days
			target = this
			variable = {
				type = name
				localization = LEADER
				scope = this
			}
			variable = {
				key = border
				value = GFX_border_legendary
			}
		}
	}
	else = {
		create_message = {
			type = MESSAGE_RECRUITED_LEADER
			localization =  MESSAGE_RECRUITED_LEADER_DESC
			days = @toast_message_days
			target = this
			variable = {
				type = name
				localization = LEADER
				scope = this
			}
			variable = {
				key = border
				value = GFX_invisible
			}
		}
	}
}

# this = leader
# CATCH_PHRASE = localisation, the catch phrase
create_message_leader_recruited_with_parameterized_catch_phrase = {
	optimize_memory
	# custome message_type MESSAGE_RETAINED_LEADER instead of MESSAGE_RECRUITED_LEADER
	# in order to not get the custome leader window - looks identitcal due to using custom_toast_content_
	if = {
		limit = {
			OR = {
				has_leader_flag = event_leader
				has_leader_flag = renowned_leader
			}
		}
		create_message = {
			type = MESSAGE_RETAINED_LEADER
			localization =  MESSAGE_RECRUITED_LEADER_DESC
			days = @toast_message_days
			target = this
			custom_toast_content_icon = GFX_icon_leader
			custom_toast_content_text = $CATCH_PHRASE$
			variable = {
				type = name
				localization = LEADER
				scope = this
			}
			variable = {
				key = border
				value = GFX_border_veteran
			}
		}
	}
	else_if = {
		limit = { has_leader_flag = legendary_leader }
		create_message = {
			type = MESSAGE_RETAINED_LEADER
			localization =  MESSAGE_RECRUITED_LEADER_DESC
			days = @toast_message_days
			target = this
			custom_toast_content_icon = GFX_icon_leader
			custom_toast_content_text = $CATCH_PHRASE$
			variable = {
				type = name
				localization = LEADER
				scope = this
			}
			variable = {
				key = border
				value = GFX_border_legendary
			}
		}
	}
	else = {
		create_message = {
			type = MESSAGE_RETAINED_LEADER
			localization =  MESSAGE_RECRUITED_LEADER_DESC
			days = @toast_message_days
			target = this
			custom_toast_content_icon = GFX_icon_leader
			custom_toast_content_text = $CATCH_PHRASE$
			variable = {
				type = name
				localization = LEADER
				scope = this
			}
			variable = {
				key = border
				value = GFX_invisible
			}
		}
	}
}
