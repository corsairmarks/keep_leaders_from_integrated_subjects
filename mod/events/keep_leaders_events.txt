namespace = keep_leaders

# flag mod as active
event = {
	id = keep_leaders.13
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		NOT = { has_global_flag = keep_leaders_installed }
	}
	immediate = {
		set_global_flag = keep_leaders_installed
	}
}

# triggered by on_subject_integrated
# ROOT = country, overlord
# FROM = country, integrated subject
country_event = {
	id = keep_leaders.1
	picture = GFX_evt_intelligence_report
	show_sound = event_vote
	title = keep_leaders.1.title
	desc = {
		trigger = {
			has_country_flag = keeping_leaders_conquest@FROM
		}
		text = keep_leaders.1.desc.conquest
	}
	desc = {
		trigger = {
			NOT = { has_country_flag = keeping_leaders_conquest@FROM }
		}
		text = keep_leaders.1.desc.integration
	}
	is_triggered_only = yes
	trigger = {
		exists = FROM
		FROM = {
			OR = {
				exists = ruler
				exists = heir
				any_owned_leader = { is_eligible_transfer_leader_class = yes }
			}
		}
	}
	immediate = {
		if = {
			limit = { has_country_flag = keeping_leaders_conquest@FROM }
			log = "country [From.GetRealName] conquered by [Root.GetRealName]"
		}
		else = {
			set_country_flag = keeping_leaders_integration@FROM
			log = "country [From.GetRealName] integrated by [Root.GetRealName]"
		}
		# "argument" for localistation and set_leader_storage_flags
		FROM = { save_event_target_as = former_owner }
		# "arguments" for transfer_leader_to_storage
		create_country = {
			type = neutral_faction
			species = FROM
			flag = event_target:former_owner
			auto_delete = no
			ignore_initial_colony_error = yes
			effect = {
				set_name = "[former_owner.GetRealName]"
				set_country_flag = former_owner@event_target:former_owner
				save_event_target_as = storage_owner
				save_event_target_as = variable_storage
		# variables for the counts from accumulate_leader
		set_variable = {
			which = leader_accumulator
			value = 0
		}
		set_variable = {
			which = leader_organic_accumulator
			value = 0
		}
		set_variable = {
					which = leader_organic_reward_accumulator
					value = 0
				}
				set_variable = {
			which = leader_organic_non_cyborg_accumulator
			value = 0
		}
		set_variable = {
					which = leader_organic_non_cyborg_reward_accumulator
					value = 0
				}
				set_variable = {
			which = leader_hive_accumulator
			value = 0
		}
		set_variable = {
			which = leader_robotic_accumulator
			value = 0
		}
		set_variable = {
			which = leader_necrophagable_accumulator
			value = 0
		}
		set_variable = {
					which = leader_necrophagable_reward_accumulator
					value = 0
				}
				set_variable = {
			which = leader_same_species_accumulator
			value = 0
		}
		set_variable = {
			which = leader_not_same_species_accumulator
			value = 0
		}
		set_variable = {
					which = leader_not_same_species_reward_accumulator
					value = 0
				}
				set_variable = {
			which = leader_transferable_accumulator
			value = 0
		}
		set_variable = {
			which = leader_transferable_or_assimilatable_accumulator
			value = 0
		}
			}
		}
		# "arguments" for accumulate_leader
		save_event_target_as = potential_owner
		# count the leaders so we know the multiplier for adding resources
		# like unity or society research for empires that qualify
		FROM = {
			capital_scope = { save_event_target_as = conquered_planet }
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_class = yes }
				accumulate_leader = yes
				tag_leader_for_reassignment = yes
				transfer_leader_to_storage = yes
			}
			create_leader = {
				species = owner_species
				class = ruler
				effect = { save_event_target_as = dummy_ruler }
			}
			if = {
				limit = { exists = ruler }
				ruler = {
					set_name = keep_leaders.former_ruler_name
					save_event_target_as = integrated_ruler
				}
				if = {
					limit = {
						event_target:integrated_ruler = {
							OR = {
								pre_ruler_leader_class = governor
								pre_ruler_leader_class = scientist
								pre_ruler_leader_class = admiral
								pre_ruler_leader_class = general
							}
						}
					}
					# force the ruler back to their pre-ruler class
					assign_leader = event_target:dummy_ruler
				}
				# else they didn't have a pre-ruler class, or it's one we don't recognize
				else = {
					# force the ruler to a non-ruler class (probably governor)
					assign_leader = event_target:dummy_ruler
					event_target:integrated_ruler = {
					set_leader_flag = clear_traits
					save_event_target_as = leader_to_replace
				}
					replace_leader_based_on_government_type = yes
					event_target:leader_to_replace = { save_event_target_as = integrated_ruler }
				}
				event_target:integrated_ruler = {
					accumulate_leader = yes
					set_leader_flag = former_ruler
					set_former_gestalt_ruler_flag = yes
					add_former_ruler_trait = yes
					transfer_leader_to_storage = yes
				}
			}
			if = {
				limit = { exists = heir }
				heir = {
					set_name = keep_leaders.former_ruler_name
					save_event_target_as = integrated_heir
				}
				if = {
					limit = {
						event_target:integrated_heir = {
							OR = {
								pre_ruler_leader_class = governor
								pre_ruler_leader_class = scientist
								pre_ruler_leader_class = admiral
								pre_ruler_leader_class = general
							}
						}
					}
					# set the heir as the ruler...
					assign_leader = event_target:integrated_heir
					# ...then force them back to their pre-ruler class by assigning the dummy back
					assign_leader = event_target:dummy_ruler
				}
				# else they didn't have a pre-ruler class, or it's one we don't recognize
				else = {
					# set the heir as the ruler...
					assign_leader = event_target:integrated_heir
					# ...then force them to a pre-ruler class by assigning the dummy back (probably governor)
					assign_leader = event_target:dummy_ruler
					event_target:integrated_heir = {
					set_leader_flag = clear_traits
					save_event_target_as = leader_to_replace
				}
					replace_leader_based_on_government_type = yes
					event_target:leader_to_replace = { save_event_target_as = integrated_heir }
				}
				event_target:integrated_heir = {
					accumulate_leader = yes
					set_leader_flag = former_heir
					add_former_heir_trait = yes
					transfer_leader_to_storage = yes
				}
			}
			event_target:dummy_ruler = { kill_leader = { show_notification = no } }
		}
	}
	# keep none
	option = {
		name = keep_leaders.1.a
		custom_tooltip = keep_leaders.1.a.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = { is_homicidal = no }
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.serv.fail_text
				NAND = {
					has_valid_civic = civic_machine_servitor
					event_target:storage_owner = {
						any_owned_leader = {
							is_eligible_transfer_leader_from_storage = yes
							is_organic_species = yes
							is_hive_species = no
			}
		}
			}
		}
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
		}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 0.5
				is_necrophage_empire = yes
			}
		}
	}
	option = {
		name = keep_leaders.1.a.pur
			custom_tooltip = keep_leaders.1.a.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
		}
			}
		trigger = { has_valid_civic = civic_fanatic_purifiers }
		custom_tooltip_with_params = {
			description = ADD_RESOURCE_EFFECT
			description_parameters = {
				RESOURCE = "[This.GetUnityName]"
				KEY = "unity"
				NUM = "[variable_storage.leader_not_same_species_reward_accumulator]"
		}
		}
		hidden_effect = {
			event_target:variable_storage = {
				set_variable = {
					which = index
					value = 0
			}
		}
			while = {
				limit = {
					event_target:variable_storage = {
						check_variable = {
							which = index
							value < leader_not_same_species_accumulator
						}
					}
				}
			add_resource = {
					unity = @keep_leaders_civic_reward_base
			}
				event_target:variable_storage = {
					change_variable = {
						which = index
						value = 1
			}
			}
			}
			event_target:storage_owner = { destroy_country = yes }
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 0.5
				is_necrophage_empire = yes
			}
			modifier = {
				factor = 3
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						NOT = { is_same_species = event_target:potential_owner }
					}
				}
			}
					}
				}
	option = {
		name = keep_leaders.1.a.swarm
		custom_tooltip = keep_leaders.1.a.swarm.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
			}
		trigger = { has_valid_civic = civic_hive_devouring_swarm }
		custom_tooltip_with_params = {
			description = ADD_RESOURCE_EFFECT
			description_parameters = {
				RESOURCE = "[This.GetSocietyResearchName]"
				KEY = "society"
				NUM = "[variable_storage.leader_organic_reward_accumulator]"
			}
		}
		hidden_effect = {
			event_target:variable_storage = {
				set_variable = {
					which = index
					value = 0
				}
			}
			while = {
				limit = {
					event_target:variable_storage = {
						check_variable = {
							which = index
							value < leader_organic_accumulator
						}
					}
				}
				add_resource = {
					society_research = @keep_leaders_civic_reward_base
				}
				event_target:variable_storage = {
					change_variable = {
						which = index
						value = 1
					}
				}
			}
			event_target:storage_owner = { destroy_country = yes }
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 20
				has_valid_civic = civic_hive_devouring_swarm
			}
		}
	}
	option = {
		name = keep_leaders.1.a.term
		custom_tooltip = keep_leaders.1.a.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = { has_valid_civic = civic_machine_terminator }
		custom_tooltip_with_params = {
			description = ADD_RESOURCE_EFFECT
			description_parameters = {
				RESOURCE = "[This.GetUnityName]"
				KEY = "unity"
				NUM = "[variable_storage.leader_organic_reward_accumulator]"
	}
			}
		hidden_effect = {
			event_target:variable_storage = {
				set_variable = {
					which = index
					value = 0
		}
			}
			while = {
				limit = {
					event_target:variable_storage = {
						check_variable = {
							which = index
							value < leader_organic_accumulator
		}
					}
				}
				add_resource = {
					unity = @keep_leaders_civic_reward_base
			}
				event_target:variable_storage = {
					change_variable = {
						which = index
						value = 1
		}
		}
		}
			event_target:storage_owner = { destroy_country = yes }
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 5
				has_valid_civic = civic_machine_terminator
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
	}
	# keep none (nice)
	option = {
		name = keep_leaders.1.b
			custom_tooltip = keep_leaders.1.b.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
		}
		}
		trigger = { is_regular_empire = yes }
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				if = {
					limit = { has_valid_civic = civic_fanatic_purifiers }
					event_target:storage_owner = { all_stored_leaders_same_species = yes }
				}
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_necrophage_empire = yes
			}
			modifier = {
				factor = 100
				has_valid_civic = civic_inwards_perfection
				}
			}
	}
	option = {
		name = keep_leaders.1.b.serv
		custom_tooltip = keep_leaders.1.b.serv.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = { has_valid_civic = civic_machine_servitor }
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				has_valid_civic = civic_machine_servitor
			}
		}
	}
	option = {
		name = keep_leaders.1.b.gest.exclusive
		custom_tooltip = keep_leaders.1.b.gest.exclusive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip.none
			description_parameters = {
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# doesn't use triggers so that these will be translated into icons
			OR = {
				has_authority = auth_hive_mind
				has_authority = auth_machine_intelligence
			}
			hidden_trigger = {
				NOR = {
					has_valid_civic = civic_machine_servitor
					has_valid_civic = civic_hive_devouring_swarm
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.term.fail_text
				if = {
					limit = { has_valid_civic = civic_machine_terminator }
					event_target:storage_owner = { all_stored_leaders_robotic_lenient = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.mach.fail_text
				if = {
					limit = {
						is_machine_empire = yes
						NOT = { has_valid_civic = civic_machine_servitor }
					}
					event_target:storage_owner = { all_stored_leaders_robotic_lenient = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.b.hive.fail_text
				if = {
					limit = { is_regular_hive_empire = yes }
					event_target:storage_owner = { all_stored_leaders_hive = yes }
				}
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
			}
	# keep mechanical only - non-assimilation
	option = {
		name = keep_leaders.1.c
		custom_tooltip = keep_leaders.1.c.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
		}
	}
			trigger = {
				is_regular_empire = yes
			hidden_trigger = {
				NOR = {
					has_valid_civic = civic_fanatic_purifiers
					has_country_flag = flesh_weakened
					has_country_flag = synthetic_empire
				}
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_organic_species = yes
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
			}
		}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.phobe.fail_text
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_country_flag = synthetic_empire
					has_policy_flag = robots_allowed
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				OR = {
					has_country_flag = synthetic_empire
					AND = {
						has_policy_flag = robots_allowed
						has_policy_flag = ai_full_rights
						}
					}
				}
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
					}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
				}
			}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 0
				is_spiritualist = yes
		}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.c.term
		custom_tooltip = keep_leaders.1.c.term.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_valid_civic = civic_machine_terminator
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_organic_species = yes
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 10
				NOT = { has_valid_civic = civic_machine_terminator }
			}
		}
		custom_tooltip_with_params = {
			description = ADD_RESOURCE_EFFECT
			description_parameters = {
				RESOURCE = "[This.GetUnityName]"
				KEY = "unity"
				NUM = "[variable_storage.leader_organic_reward_accumulator]"
			}
		}
		hidden_effect = {
			event_target:variable_storage = {
				set_variable = {
					which = index
					value = 0
				}
			}
			while = {
					limit = {
					event_target:variable_storage = {
						check_variable = {
							which = index
							value < leader_organic_accumulator
							}
						}
					}
				add_resource = {
					unity = @keep_leaders_civic_reward_base
				}
				event_target:variable_storage = {
					change_variable = {
						which = index
						value = 1
				}
			}
			}
			}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
		}
	option = {
		name = keep_leaders.1.c.mach
		custom_tooltip = keep_leaders.1.c.mach.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# doesn't use a trigger so that this will be translated into an icon
			has_authority = auth_machine_intelligence
			hidden_trigger = {
				NOR = {
					has_valid_civic = civic_machine_assimilator
					has_valid_civic = civic_machine_terminator
				}
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_organic_species = yes
					is_hive_species = no
				}
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_robotic_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.serv.fail_text
				NOT = { has_valid_civic = civic_machine_servitor }
			}
				}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 10
				is_machine_empire = yes
				NOR = {
					has_valid_civic = civic_machine_assimilator
					has_valid_civic = civic_machine_servitor
					has_valid_civic = civic_machine_terminator
			}
				}
			}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
			}
	}
	option = {
		name = keep_leaders.1.c.mach.exclusive
		custom_tooltip = keep_leaders.1.c.mach.exclusive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			# doesn't use a trigger so that this will be translated into an icon
			has_authority = auth_machine_intelligence
			hidden_trigger = {
				NOT = { has_valid_civic = civic_machine_assimilator }
				event_target:storage_owner = { all_stored_leaders_robotic_strict = yes }
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 10
				is_machine_empire = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
			}
		}
	option = {
		name = keep_leaders.1.c.cyb
		custom_tooltip = keep_leaders.1.c.cyb.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			OR = {
				has_ascension_perk = ap_the_flesh_is_weak
				has_civic = civic_machine_assimilator
			}
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_organic_species = yes
						is_cyborg_species = no
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species_lenient = yes
					}
				}
			}
		}
		allow = {
			OR = {
				has_country_flag = flesh_weakened
				has_valid_civic = civic_machine_assimilator
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.c.cyb.exclusive
		custom_tooltip = keep_leaders.1.c.cyb.exclusive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
			trigger = {
			OR = {
				has_ascension_perk = ap_the_flesh_is_weak
				has_civic = civic_machine_assimilator
			}
			hidden_trigger = { event_target:storage_owner = { all_stored_leaders_robotic_lenient = yes } }
		}
		allow = {
			OR = {
				has_country_flag = flesh_weakened
				has_valid_civic = civic_machine_assimilator
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 5
				has_valid_civic = civic_machine_assimilator
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
		}
	# keep mechanical only (nice) - non-assimilation
	option = {
		name = keep_leaders.1.d
			custom_tooltip = keep_leaders.1.d.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
		}
		}
		trigger = {
			hidden_trigger = {
				is_regular_empire = yes
				NOT = { has_valid_civic = civic_fanatic_purifiers }
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_organic_species = yes
						is_hive_species = no
					}
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_robotic_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_country_flag = synthetic_empire
					has_policy_flag = robots_allowed
				}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				OR = {
					has_country_flag = synthetic_empire
					AND = {
						has_policy_flag = robots_allowed
						has_policy_flag = ai_full_rights
					}
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.phobe.fail_text
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_robotic_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_materialist = yes
			}
			modifier = {
				factor = 0
				is_spiritualist = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.d.serv
		custom_tooltip = keep_leaders.1.d.serv.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_valid_civic = civic_machine_servitor
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_organic_species = yes
						is_hive_species = no
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 10
				has_valid_civic = civic_machine_servitor
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.10
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# keep organic only - non-assimilation
	option = {
		name = {
			text = keep_leaders.1.e
			trigger = { is_spiritualist = no }
		}
		name = {
			text = keep_leaders.1.e.spir
			trigger = { is_spiritualist = yes }
			}
		custom_tooltip = keep_leaders.1.e.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_organic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
		}
		}
			trigger = {
			OR = {
				has_policy_flag = robots_outlawed
				has_policy_flag = ai_outlawed
				has_policy_flag = ai_servitude
			}
			hidden_trigger = {
				NOR = {
					has_country_flag = synthetic_empire
					has_valid_civic = civic_fanatic_purifiers
		}
			is_regular_empire = yes
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_organic_species = yes
					is_hive_species = no
				}
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_robotic_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				NOT = { has_valid_civic = civic_fanatic_purifiers }
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_organic_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_organic_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_spiritualist = yes
			}
			modifier = {
				factor = 0
				is_materialist = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.11
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.e.ai
		custom_tooltip = keep_leaders.1.e.ai.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_organic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			OR = {
				hidden_trigger = { has_country_flag = synthetic_empire }
				AND = {
					has_policy_flag = robots_allowed
					has_policy_flag = ai_full_rights
				}
			}
			hidden_trigger = {
				is_regular_empire = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_organic_species = yes
						is_hive_species = no
			}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
		}
			}
		}
	}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				NOT = { has_valid_civic = civic_fanatic_purifiers }
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_organic_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_organic_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_spiritualist = yes
			}
			modifier = {
				factor = 0
				is_materialist = yes
		}
			}
		hidden_effect = {
			country_event = {
				id = keep_leaders.11
				scopes = { from = event_target:storage_owner }
		}
			}
		}
	# same species only
	option = {
		name = keep_leaders.1.g
			custom_tooltip = keep_leaders.1.g.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_same_species_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				NOT = { has_valid_civic = civic_fanatic_purifiers }
			is_regular_empire = yes
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_same_species = event_target:potential_owner
				}
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					NOT = { is_same_species = event_target:potential_owner }
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
			custom_tooltip = {
				fail_text = empire_is_pacifist_no_x
				is_pacifist = no
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 0
				has_valid_civic = civic_fanatic_purifiers
			}
			modifier = {
				factor = 0.5
				has_origin = origin_necrophage
				has_trait = trait_necrophage
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.12
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	option = {
		name = keep_leaders.1.g.pur
		custom_tooltip = keep_leaders.1.g.pur.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_same_species_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_valid_civic = civic_fanatic_purifiers
			hidden_trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_same_species = event_target:potential_owner
					}
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						NOT = { is_same_species = event_target:potential_owner }
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_xenophobe = yes
			}
			modifier = {
				factor = 2
				has_valid_civic = civic_fanatic_purifiers
			}
			modifier = {
				factor = 0.5
				has_origin = origin_necrophage
				has_trait = trait_necrophage
			}
		}
		custom_tooltip_with_params = {
			description = ADD_RESOURCE_EFFECT
			description_parameters = {
				RESOURCE = "[This.GetUnityName]"
				KEY = "unity"
				NUM = "[variable_storage.leader_not_same_species_reward_accumulator]"
			}
		}
		hidden_effect = {
			event_target:variable_storage = {
				set_variable = {
					which = index
					value = 0
				}
			}
			while = {
				limit = {
					event_target:variable_storage = {
						check_variable = {
							which = index
							value < leader_not_same_species_accumulator
						}
					}
				}
				add_resource = {
					unity = @keep_leaders_civic_reward_base
				}
				event_target:variable_storage = {
					change_variable = {
						which = index
						value = 1
					}
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.12
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# same species only (nice)
	option = {
		name = keep_leaders.1.h
		custom_tooltip = keep_leaders.1.h.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_same_species_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
			is_regular_empire = yes
			NOT = { has_valid_civic = civic_fanatic_purifiers }
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_same_species = event_target:potential_owner
				}
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					NOT = { is_same_species = event_target:potential_owner }
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = empire_is_xenophile_no_x
				is_xenophile = no
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 0.5
				is_xenophobe = yes
			}
			modifier = {
				factor = 4
				is_necrophage_empire = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.12
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# hive keep hive only
	option = {
		name = {
			text = keep_leaders.1.i.hive
			trigger = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_hive_species = no
					}
				}
			}
		}
		name = {
			text = keep_leaders.1.i.hive.exclusive
			trigger = { event_target:storage_owner = { all_stored_leaders_hive = yes } }
		}
		if = {
			limit = {
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_hive_species = no
					}
				}
			}
			custom_tooltip = keep_leaders.1.i.hive.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.i.hive.exclusive.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_hive_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			has_authority = auth_hive_mind
			hidden_trigger = {
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_hive_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.swarm.fail_text
				NOT = { has_valid_civic = civic_hive_devouring_swarm }
			}
		}
		ai_chance = {
			factor = 5
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.14
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# try to keep as many as possible
	option = {
		name = {
			text = keep_leaders.1.j
			trigger = { NOT = { has_valid_civic = civic_fanatic_purifiers } }
		}
		name = {
			text = keep_leaders.1.j.pur
			trigger = { has_valid_civic = civic_fanatic_purifiers }
		}
		if = {
			limit = { NOT = { has_valid_civic = civic_fanatic_purifiers } }
			custom_tooltip = keep_leaders.1.j.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.j.pur.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			is_regular_empire = yes
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = {
						is_necrophage_empire = yes
						event_target:variable_storage = {
							check_variable = {
								which = leader_transferable_accumulator
								value > 0
				}
			}
					}
					event_target:storage_owner = { any_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = {
						event_target:variable_storage = {
							check_variable = {
								which = leader_transferable_accumulator
								value > 0
							}
				}
						is_xenophobe = yes
					}
					event_target:storage_owner = { any_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
			}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.pur.fail_text
				if = {
					limit = { has_valid_civic = civic_fanatic_purifiers }
					event_target:storage_owner = { all_stored_leaders_same_species = yes }
				}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.j.fail_text
				event_target:variable_storage = {
					check_variable = {
						which = leader_transferable_accumulator
						value > 0
					}
				}
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				is_pacifist = yes
			}
			modifier = {
				factor = 2
				is_xenophile = yes
			}
			modifier = {
				factor = 2
				has_full_ai_rights = yes
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_robotic_species = yes
					}
				}
			}
			modifier = {
				factor = 0
				has_valid_civic = civic_inwards_perfection
			}
			modifier = {
				factor = 20
				has_valid_civic = civic_fanatic_purifiers
				event_target:storage_owner = { all_stored_leaders_same_species = yes }
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.15
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: hive
	option = {
		name = keep_leaders.1.k.hive
		icon = {
			icon = GFX_ap_evolutionary_mastery
			text = keep_leaders.1.k.gene.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.hive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				has_utopia = yes
			}
			event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_eligible_for_hive_assimilation_species = yes
				}
			}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.k.bio.fail_text
				has_ascension_perk = ap_evolutionary_mastery
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.swarm.fail_text
				NOT = { has_valid_civic = civic_hive_devouring_swarm }
			}
		}
		ai_chance = {
			factor = 10
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: unhive
	option = {
		name = keep_leaders.1.k.unhive
		icon = {
			icon = GFX_ap_evolutionary_mastery
			text = keep_leaders.1.k.gene.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.unhive.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				has_utopia = yes
			is_hive_empire = no
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_eligible_for_unhive_assimilation_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.k.bio.fail_text
				has_ascension_perk = ap_evolutionary_mastery
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
		}
		ai_chance = {
			factor = 10
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: psionic
	option = {
		name = keep_leaders.1.k.psi
		icon = {
			icon = GFX_ap_transcendence
			text = keep_leaders.1.k.psi.icon.tooltip
		}
		if = {
			limit = { NOT = { has_global_flag = deassimilate_machines_installed } }
			custom_tooltip = keep_leaders.1.k.psi.tooltip
		}
		else = {
			custom_tooltip = keep_leaders.1.k.psi.allow-cyb.tooltip
		}
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				has_utopia = yes
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_eligible_for_psionic_assimilation_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.k.psionic.fail_text
				has_ascension_perk = ap_transcendence
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
		}
		ai_chance = {
			factor = 10
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: cybernetic
	option = {
		name = keep_leaders.1.k.cyb
		icon = {
			icon = GFX_ap_the_flesh_is_weak
			text = keep_leaders.1.k.cyb.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.cyb.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				has_utopia = yes
				NOT = { has_country_flag = synthetic_empire }
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_eligible_for_cybernetic_assimilation_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.k.cyb1.fail_text
				has_ascension_perk = ap_the_flesh_is_weak
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.cyb2.fail_text
				has_country_flag = flesh_weakened
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
		}
		ai_chance = {
			factor = 10
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}	
		}
	}
	# assimilate: synthetic
	option = {
		name = keep_leaders.1.k.synth
		icon = {
			icon = GFX_ap_synthetic_evolution
			text = keep_leaders.1.k.synth.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.synth.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				has_utopia = yes
				has_country_flag = flesh_weakened
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_eligible_for_synthetic_assimilation_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.k.synth1.fail_text
				has_ascension_perk = ap_synthetic_evolution
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.k.synth2.fail_text
				has_country_flag = synthetic_empire
			}
		}
		ai_chance = {
			factor = 10
			modifier = {
				factor = 0.5
				is_xenophile = yes
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: assimilator
	option = {
		name = keep_leaders.1.k.assim
		custom_tooltip = keep_leaders.1.k.assim.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_transferable_or_assimilatable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			OR = {
				has_valid_civic = civic_machine_assimilator # explicit to get the icon to show
				hidden_trigger = { is_machine_empire = yes }
			}
			hidden_trigger = {
				has_synthethic_dawn = yes
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_eligible_for_machine_assimilation_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = keep_leaders.1.k.mach.fail_text
				has_valid_civic = civic_machine_assimilator
			}
		}
		ai_chance = {
			factor = 20
		}
		custom_tooltip_with_params = {
			description = ADD_RESOURCE_EFFECT
			description_parameters = {
				RESOURCE = "[This.GetUnityName]"
				KEY = "unity"
				NUM = "[variable_storage.leader_organic_non_cyborg_reward_accumulator]"
			}
		}
		custom_tooltip_with_params = {
			description = ADD_RESOURCE_EFFECT
			description_parameters = {
				RESOURCE = "[This.GetSocietyResearchName]"
				KEY = "society"
				NUM = "[variable_storage.leader_organic_non_cyborg_reward_accumulator]"
			}
		}
		hidden_effect = {
			event_target:variable_storage = {
				set_variable = {
					which = index
					value = 0
				}
			}
			while = {
				limit = {
					event_target:variable_storage = {
						check_variable = {
							which = index
							value < leader_organic_non_cyborg_accumulator
						}
					}
				}
				add_resource = {
					unity = @keep_leaders_civic_reward_base
					society_research = @keep_leaders_civic_reward_base
				}
				event_target:variable_storage = {
					change_variable = {
						which = index
						value = 1
					}
			}
		}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# assimilate: unmachine
	option = {
		name = keep_leaders.1.k.unmach
		icon = {
			icon = GFX_icon_tech_sapient_ai_alternate
			text = keep_leaders.1.k.unmach.icon.tooltip
		}
		custom_tooltip = keep_leaders.1.k.unmach.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_robotic_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = {
				has_synthethic_dawn = yes
				has_utopia = yes
				has_global_flag = deassimilate_machines_installed
			is_regular_empire = yes
				event_target:storage_owner = {
				any_owned_leader = {
					is_eligible_transfer_leader_from_storage = yes
					is_machine_species = yes
				}
			}
		}
		}
		allow = {
			custom_tooltip = {
				fail_text = disconnected_machine_leaders_collapse_without_ai_assimilation_no_x
				has_technology = tech_sapient_ai
			}
			custom_tooltip = {
				fail_text = ROBOTS_ARE_OUTLAWED_NO_X
				OR = {
					has_country_flag = synthetic_empire
				has_policy_flag = robots_allowed
			}
			}
			custom_tooltip = {
				fail_text = AI_IS_OUTLAWED_LEADER_NO_X
				OR = {
					has_country_flag = synthetic_empire
					AND = {
						has_policy_flag = robots_allowed
						has_policy_flag = ai_full_rights
			}
		}
			}
			custom_tooltip = {
				fail_text = keep_leaders.1.necro.fail_text
				if = {
					limit = { is_necrophage_empire = yes }
					event_target:storage_owner = { all_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
		}
			}
			custom_tooltip = {
				fail_text = empire_is_xenophobe_no_x
				if = {
					limit = { is_xenophobe = yes }
					event_target:storage_owner = { all_stored_leaders_eligible_transfer_to_main_species_leader_restricted = yes }
				}
			}
		}
		hidden_effect = {
			country_event = {
				id = keep_leaders.16
				scopes = { from = event_target:storage_owner }
			}
		}
	}
	# necrophage (kinda like assimilation in terms of the outcome)
	option = {
		name = keep_leaders.1.k.necro
		custom_tooltip = keep_leaders.1.k.necro.tooltip
		custom_tooltip_with_params = {
			description = keep_leaders.1.tooltip
			description_parameters = {
				VALUE = "[variable_storage.leader_necrophagable_accumulator]"
				TOTAL = "[variable_storage.leader_accumulator]"
			}
		}
		trigger = {
			hidden_trigger = { has_necroids = yes }
			# doesn't use a trigger so that this will be translated into an icon
			has_origin = origin_necrophage
			hidden_trigger = { has_trait = trait_necrophage }
		}
		allow = {
			custom_tooltip = {
				fail_text = CANNOT_NECROPHAGE_MACHINES_NO_X
				event_target:storage_owner = {
					any_owned_leader = {
						is_eligible_transfer_leader_from_storage = yes
						is_organic_species = yes
					}
				}
			}
			custom_tooltip = {
				fail_text = NECROPHAGE_NONE_ELIGIBLE_NO_X
				event_target:variable_storage = {
					check_variable = {
						which = leader_necrophagable_accumulator
						value > 0
					}
		}
			}
		}
		ai_chance = {
			factor = 10
			modifier = {
				factor = 2
				has_policy_flag = purge_allowed
			}
		}
		# necrophage unity
		if = {
			limit = { has_swapped_tradition = tr_harmony_unity_of_self }
		custom_tooltip_with_params = {
				description = ADD_RESOURCE_EFFECT
			description_parameters = {
					RESOURCE = "[This.GetUnityName]"
					KEY = "unity"
					NUM = "[variable_storage.leader_necrophagable_reward_accumulator]"
			}
		}
		hidden_effect = {
				event_target:variable_storage = {
					set_variable = {
						which = index
						value = 0
			}
		}
				while = {
					limit = {
						event_target:variable_storage = {
							check_variable = {
								which = index
								value < leader_necrophagable_accumulator
			}
			}
			}
					add_resource = {
						unity = @keep_leaders_civic_reward_base
			}
					event_target:variable_storage = {
						change_variable = {
							which = index
							value = 1
			}
			}
					}
				}
			}
		hidden_effect = {
			country_event = {
				id = keep_leaders.17
				scopes = { from = event_target:storage_owner }
			}
		}
	}
}

# triggered by on_planet_attackers_win (same on_action as primitive planet conquest action.14)
# ROOT = country, leader attacker
# FROM = country, planet owner
# FROMFROM = planet
country_event = {
	id = keep_leaders.2
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		is_country_type = default
		FROM = { is_country_type = primitive }
	}
	immediate = {
		log = "primitive planet [FromFrom.GetName] ([From.GetRealName]) conquered by [Root.GetRealName]"
		set_country_flag = keeping_leaders_conquest@FROM
		# fires the above event - hooray for reuse!
		country_event = {
			id = keep_leaders.1
			scopes = {
				from = FROM
			}
		}
	}
}

# window with options to potentially keep the stored leaders
# triggered by on_primitive_planet_transferred
# ROOT = planet (after ownership change)
# FROM = country, infiltrated primitives
planet_event = {
	id = keep_leaders.3
	title = keep_leaders.3.title
	desc = keep_leaders.3.desc
	picture = GFX_evt_diplomatic_visit
	is_triggered_only = yes
	trigger = {
		exists = owner
		owner = { has_country_flag = keeping_leaders_infiltration@FROM }
		exists = FROM
		any_country = {
			is_country_type = neutral_faction
			has_country_flag = former_owner@FROM
			any_owned_leader = {
				has_leader_flag = former_owner@FROM
				has_leader_flag = potential_owner@PREVPREV.owner
			}
		}
	}
	immediate = {
		# acquire leader and variable storage
		random_country = {
			limit = {
				is_country_type = neutral_faction
				has_country_flag = former_owner@FROM
			}
			save_event_target_as = storage_owner
			save_event_target_as = variable_storage
		}
		owner = { save_event_target_as = potential_owner }
		FROM = {
			save_event_target_as = former_owner
			owner_species = { save_event_target_as = original_species }
		}
	}
	option = {
		name = keep_leaders.3.a
		custom_tooltip_with_params = {
			description = keep_leaders.3.a.tooltip
			description_parameters = {
				VALUE = "[variable_storage.infiltration_leader_accumulator]"
			}
		}
		hidden_effect = {
			event_target:storage_owner = {
				every_owned_leader = {
					limit = { is_eligible_transfer_leader_from_storage = yes }
					set_owner = event_target:potential_owner
					fire_on_action = { on_action = on_leader_owner_changed }
					change_species = event_target:potential_owner
					fire_on_action = { on_action = on_leader_species_changed }
				}
				destroy_country = yes
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				owner = { is_xenophobe = yes }
			}
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					OR = {
						has_ai_personality_behaviour = displacer
						has_ai_personality_behaviour = slaver
					}
				}
			}
		}
	}
	option = {
		name = keep_leaders.3.b
		custom_tooltip_with_params = {
			description = keep_leaders.3.b.tooltip
			description_parameters = {
				VALUE = "[variable_storage.infiltration_leader_accumulator]"
			}
		}
		hidden_effect = {
			event_target:storage_owner = {
				every_owned_leader = {
					limit = { is_eligible_transfer_leader_from_storage = yes }
					species = { save_event_target_as = former_species }
					set_owner = event_target:potential_owner
					fire_on_action = { on_action = on_leader_owner_changed }
					change_species = event_target:potential_owner
					change_leader_portrait = event_target:former_species
					fire_on_action = { on_action = on_leader_species_changed }
				}
				destroy_country = yes
			}
		}
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				owner = { is_authoritarian = yes }
			}
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					has_ai_personality_behaviour = infiltrator
				}
			}
		}
	}
	option = {
		name = keep_leaders.3.c
		owner = {
			add_modifier = {
				modifier = kl_peerless_infiltration_agents
				years = 20
			}
		}
		hidden_effect = { event_target:storage_owner = { destroy_country = yes } }
		ai_chance = {
			factor = 1
			modifier = {
				factor = 2
				owner = {
					has_valid_ai_personality = yes
					OR = {
						has_ai_personality_behaviour = multispecies
						has_ai_personality = hegemonic_imperialists
					}
				}
			}
			modifier = {
				factor = 0
				owner = {
					has_valid_ai_personality = yes
					has_ai_personality = honorbound_warriors
				}
			}
		}
	}
	after = {
		hidden_effect = {
			# recalculate former ruler country bonuses
			owner = {
				country_event = {
					id = keep_leaders_bonus_traits.20
				}
			}
		}
	}
}

# transfer leaders to storage while the primitive country exists
# triggered by on_primitive_planet_transferring
# ROOT = planet (before ownership change)
# FROM = country, infiltrator
planet_event = {
	id = keep_leaders.4
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		exists = owner
		owner = {
			OR = {
				exists = ruler
				exists = heir
				any_owned_leader = { is_eligible_transfer_leader_class = yes }
			}
		}
		exists = FROM
		has_observation_outpost = yes
		observation_outpost = {
			has_mission = covert_infiltration
			mission_progress >= 1
		}
	}
	immediate = {
		# "argument" for localistation and set_leader_storage_flags
		owner = { save_event_target_as = former_owner }
		# "arguments" for transfer_leader_to_storage
		create_country = {
			type = neutral_faction
			flag = event_target:former_owner
			auto_delete = no
			ignore_initial_colony_error = yes
			effect = {
				set_name = "[former_owner.GetRealName]"
				set_country_flag = former_owner@event_target:former_owner
				save_event_target_as = storage_owner
				save_event_target_as = variable_storage
				# variable for leader count
		set_variable = {
			which = infiltration_leader_accumulator
			value = 0
		}
			}
		}
		FROM = {
			set_country_flag = keeping_leaders_infiltration@PREV.owner
			save_event_target_as = potential_owner
		}
		owner = {
			owner_species = { save_event_target_as = original_species }
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_class = yes }
				event_target:variable_storage = {
					change_variable = {
						which = infiltration_leader_accumulator
						value = 1
					}
				}
				transfer_leader_to_storage = yes
			}
			create_leader = {
				species = owner_species
				class = ruler
			}
			# can't save in effect - is it because the country is being deleted?
			last_created_leader = { save_event_target_as = dummy_ruler }
			if = {
				limit = { exists = ruler }
				event_target:variable_storage = {
					change_variable = {
						which = infiltration_leader_accumulator
						value = 1
					}
				}
				ruler = {
					set_name = keep_leaders.former_ruler_name
					save_event_target_as = integrated_ruler
				}
				if = {
					limit = {
						event_target:integrated_ruler = {
							OR = {
								pre_ruler_leader_class = governor
								pre_ruler_leader_class = scientist
								pre_ruler_leader_class = admiral
								pre_ruler_leader_class = general
							}
						}
					}
					# force the ruler back to their pre-ruler class
					assign_leader = event_target:dummy_ruler
				}
				# else they didn't have a pre-ruler class, or it's one we don't recognize
				else = {
					# force the ruler to a non-ruler class (probably governor)
					assign_leader = event_target:dummy_ruler
					event_target:integrated_ruler = {
					set_leader_flag = clear_traits
					save_event_target_as = leader_to_replace
				}
					replace_leader_based_on_government_type = yes
					event_target:leader_to_replace = { save_event_target_as = integrated_ruler }
				}
				event_target:integrated_ruler = {
					set_leader_flag = former_ruler
					set_former_gestalt_ruler_flag = yes
					add_former_ruler_trait = yes
					transfer_leader_to_storage = yes
				}
			}
			if = {
				limit = { exists = heir }
				event_target:variable_storage = {
					change_variable = {
						which = infiltration_leader_accumulator
						value = 1
					}
				}
				heir = {
					set_name = keep_leaders.former_ruler_name
					save_event_target_as = integrated_heir
				}
				if = {
					limit = {
						event_target:integrated_heir = {
							OR = {
								pre_ruler_leader_class = governor
								pre_ruler_leader_class = scientist
								pre_ruler_leader_class = admiral
								pre_ruler_leader_class = general
							}
						}
					}
					# set the heir as the ruler...
					assign_leader = event_target:integrated_heir
					# ...then force them back to their pre-ruler class by assigning the dummy back
					assign_leader = event_target:dummy_ruler
				}
				# else they didn't have a pre-ruler class, or it's one we don't recognize
				else = {
					# set the heir as the ruler...
					assign_leader = event_target:integrated_heir
					# ...then force them to a pre-ruler class by assigning the dummy back (probably governor)
					assign_leader = event_target:dummy_ruler
					event_target:integrated_heir = {
					set_leader_flag = clear_traits
					save_event_target_as = leader_to_replace
				}
					replace_leader_based_on_government_type = yes
					event_target:leader_to_replace = { save_event_target_as = integrated_heir }
				}
				event_target:integrated_heir = {
					set_leader_flag = former_heir
					add_former_heir_trait = yes
					transfer_leader_to_storage = yes
				}
			}
			event_target:dummy_ruler = { kill_leader = { show_notification = no } }
		}
	}
}

# triggered by on_subject_integrated
# ROOT = country, overlord
# FROM = country, integrated subject
country_event = {
	id = keep_leaders.5
	hide_window = yes
	is_triggered_only = yes
	immediate = {
			set_variable = {
				which = keep_leaders_army_transport_fleet
				value = 13 # semi-arbitrary start value
			}
		save_event_target_as = integrating_country
		FROM = {
			save_event_target_as = integrated_country
		# tag each army with a variable value that corresponds to one set on its transport fleet
		every_owned_army = {
			log = "[This.GetName] owned by [This.Owner.GetName]"
			if = {
				limit = { exists = fleet }
				if = {
					limit = { fleet = { NOT = { is_variable_set = keep_leaders_army_transport_fleet } } }
					fleet = {
						set_variable = {
							which = keep_leaders_army_transport_fleet
								value = event_target:integrating_country
						}
					}
						event_target:integrating_country = {
						change_variable = {
							which = keep_leaders_army_transport_fleet
							value = 1
						}
					}
				}
				set_variable = {
					which = keep_leaders_army_transport_fleet
					value = fleet
				}
			}
		}
		every_owned_fleet = {
			limit = { is_ship_class = shipclass_transport }
			save_event_target_as = source_fleet
			log = "[source_fleet.GetName] is a transport fleet"
				event_target:integrating_country = {
				create_fleet = {
					effect = {
						if = {
							limit = { event_target:source_fleet = { is_variable_set = keep_leader_match_transport_fleet } }
							set_variable = {
								which = keep_leader_match_transport_fleet
								value = event_target:source_fleet
							}
							event_target:source_fleet = { clear_variable = keep_leader_match_transport_fleet }
						}
						save_event_target_as = target_fleet
						set_name = "[source_fleet.GetName]"
							set_owner = event_target:integrating_country
						set_location = event_target:source_fleet
						event_target:source_fleet = {
							every_owned_ship = {
								save_event_target_as = source_ship
								log = "transport [source_ship.GetName]"
								event_target:target_fleet = {
									event_target:source_fleet.owner = {
										random_owned_army = {
											limit = {
												is_variable_set = keep_leaders_army_transport_fleet
												check_variable = {
													which = keep_leaders_army_transport_fleet
													value = event_target:source_fleet
												}
											}
											log = "army [This.GetName] was in fleet [source_fleet.GetName]"
											clear_variable = keep_leaders_army_transport_fleet
											save_event_target_as = source_army
										}
									}
									event_target:source_army = {
										switch = {
											trigger = army_type
											assault_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = assault_army } } }
											clone_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = clone_army } } }
											cybrex_warform = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = cybrex_warform } } }
											gene_warrior_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = gene_warrior_army } } }
											machine_assault_1 = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_1 } } }
											machine_assault_2 = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_2 } } }
											machine_assault_3 = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = machine_assault_3 } } }
											psionic_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = psionic_army } } }
											robotic_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = robotic_army } } }
											shroud_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = shroud_army } } }
											slave_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = slave_army } } }
											titanic_assault_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = titanic_assault_army } } }
											undead_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = undead_army } } }
											xenomorph_army = { PREV = { create_army_transport_parameterized = { ARMY_TYPE = xenomorph_army } } }
											default = {
												log = "unhandled army type for [This.GetName] owned by [This.Owner.GetRealName] - used assault_army"
												PREV = { create_army_transport_parameterized = { ARMY_TYPE = assault_army } }
											}
										}
									}
								}
							}
						}
					}
				}
			}
			delete_fleet = THIS
		}
	}
}
}

# randomise a leader's experience between 0 and the maximum for their current level
# triggered by an effect, because directly invoking the effect directly resulted in exceeding the maximum call depth of 5
# ROOT = leader
leader_event = {
	id = keep_leaders.6
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		randomise_leader_xp = yes
	}
}

# triggered by on_monthly_pulse_country
# ROOT = country
country_event = {
	id = keep_leaders.7
	hide_window = yes
	is_triggered_only = yes
	immediate = {
		log = "monthly pulse [This.GetName]"
		country_event = {
			id = keep_leaders.8
			days = 29
		}
	}
}

# triggered monthly on the 30th
# ROOT = country
country_event = {
	id = keep_leaders.8
	hide_window = yes
	is_triggered_only = yes
	trigger = {
		count_subject = { count > 0 }
		any_owned_fleet = { is_ship_class = shipclass_transport }
	}
	immediate = {
		log = "30th [This.GetName] [GetDate]"
		every_subject = {
			every_owned_planet = {
				limit = { is_colony = yes }
				solar_system = {
					set_timed_star_flag = {
						flag = keep_leaders_subject_system
						days = 2
					}
				}
			}
			every_owned_megastructure = {
				limit = { is_colony = yes }
				solar_system = {
					set_timed_star_flag = {
						flag = keep_leaders_subject_system
						days = 2
					}
				}
			}
		}
		every_owned_fleet = {
			limit = { is_ship_class = shipclass_transport }
			set_timed_fleet_flag = {
				flag = keep_leaders_already_owned
				days = 2
			}
		}
		# ideally, I could check whether a subject is about the be integrated and clone thier fleets 1 day ahead
		# but I'm not finding a way to check whether an integration is in progress, or what the progress might be
	}
}

# keep robotic only
# ROOT = country, integrator or conqueror
# FROM = country, leader storage
country_event = {
	id = keep_leaders.10
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.10 keep robotic only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		FROM = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_robotic_species_lenient = yes
				}
				if = {
					limit = {
						OR = {
							event_target:potential_owner = {
								is_necrophage_empire = no
								is_xenophobe = no
							}
							is_bypass_leader_restriction_honored_protectors = yes
						}
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
}
}

# keep organic only
# ROOT = country, integrator or conqueror
# FROM = country, leader storage
country_event = {
	id = keep_leaders.11
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.11 keep organic only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		FROM = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_organic_species = yes
				}
				if = {
					limit = {
						OR = {
							event_target:potential_owner = {
								is_necrophage_empire = no
								is_xenophobe = no
							}
							is_bypass_leader_restriction_honored_protectors = yes
						}
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
}
	}
}

# keep same species only
# ROOT = country, integrator or conqueror
# FROM = country, leader storage
country_event = {
	id = keep_leaders.12
	is_triggered_only = yes
	hide_window = yes
	immediate = {
		log = "keep_leaders.12 keep same species only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		FROM = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_same_species = event_target:potential_owner
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
	}
}

# keep hive only
# ROOT = country, integrator or conqueror
# FROM = country, leader storage
country_event = {
	id = keep_leaders.14
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		has_utopia = yes
		is_regular_hive_empire = yes
	}
	immediate = {
		log = "keep_leaders.14 keep hive only"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		FROM = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_hive_species = yes
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
}
	}
}

# keep 'em all!
# ROOT = country, integrator or conqueror
# FROM = country, leader storage
country_event = {
	id = keep_leaders.15
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		is_regular_empire = yes
	}
	immediate = {
		log = "keep_leaders.15 keep as many as possible"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		FROM = {
			every_owned_leader = {
				limit = {
					is_eligible_transfer_leader_from_storage = yes
					is_eligible_transfer_without_assimilation = yes
				}
				ensure_species_rights_and_take_ownership_of_leader = yes
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
}
}

# assimilate
# ROOT = country, integrator or conqueror
# FROM = country, leader storage
country_event = {
	id = keep_leaders.16
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		has_utopia = yes
	}
	immediate = {
		log = "keep_leaders.16 assimilation"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		FROM = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				if = {
					limit = { event_target:potential_owner = { is_machine_empire = yes } }
					if = {
						limit = { is_eligible_for_machine_assimilation_species = yes }
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_ego_assimilation
						}
						modify_species = {
							species = species
							add_trait = trait_cybernetic
							add_traits_at_start_of_list = yes
							change_scoped_species = no
							effect = {
								save_event_target_as = cyborg_species
							}
						}
						if = {
							limit = { event_target:cyborg_species = { has_trait = trait_hive_mind } }
							modify_species = {
								base = species
								species = event_target:cyborg_species
								remove_trait = trait_hive_mind
								change_scoped_species = no
								effect = {
									save_event_target_as = cyborg_species
								}
							}
						}
						if = {
							limit = { event_target:cyborg_species = { has_trait = trait_self_modified } }
							modify_species = {
								base = species
								species = event_target:cyborg_species
								remove_trait = trait_self_modified
								change_scoped_species = no
								effect = {
									save_event_target_as = cyborg_species
								}
							}
						}
						change_species = event_target:cyborg_species
						ensure_species_rights_and_take_ownership_of_leader = yes
						fire_on_action = { on_action = on_leader_species_changed }
					}
					else_if = {
						limit = { is_eligible_transfer_without_assimilation = yes }
						ensure_species_rights_and_take_ownership_of_leader = yes
					}
				}
				else_if = {
					limit = { event_target:potential_owner = { is_hive_empire = yes } }
					if = {
						limit = { is_eligible_for_hive_assimilation_species = yes }
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_ego_assimilation
						}
						modify_species = {
							species = species
							add_trait = trait_hive_mind
							add_traits_at_start_of_list = yes
							change_scoped_species = no
							effect = {
								save_event_target_as = hived_species
							}
						}
						if = {
							limit = { event_target:hived_species = { has_trait = trait_self_modified } }
							modify_species = {
								base = species
								species = event_target:hived_species
								remove_trait = trait_self_modified
								change_scoped_species = no
								effect = {
									save_event_target_as = hived_species
								}
							}
						}
						change_species = event_target:hived_species
						ensure_species_rights_and_take_ownership_of_leader = yes
						fire_on_action = { on_action = on_leader_species_changed }
					}
					else_if = {
						limit = { is_eligible_transfer_without_assimilation = yes }
						ensure_species_rights_and_take_ownership_of_leader = yes
					}
				}
				else_if = {
					limit = { event_target:potential_owner = { is_regular_empire = yes } }
					if = {
						limit = {
							has_global_flag = deassimilate_machines_installed
							is_eligible_for_unmachine_assimilation_species = yes
						}
						species = {
							save_event_target_as = machine_species
							set_citizenship_type = {
								country = event_target:potential_owner
								type = citizenship_assimilation
							}
							set_living_standard = {
								country = event_target:potential_owner
								type = living_standard_deassimilation
							}
						}
						random_galaxy_species = {
							limit = { has_species_flag = mechanical_species_of_machine_species@event_target:machine_species }
							ROOT = { set_country_flag = found_assim_mech_species@event_target:machine_species }
							save_event_target_as = mechanical_species
						}
						if = {
							limit = { ROOT = { NOT = { has_country_flag = found_assim_mech_species@event_target:machine_species } } }
							event_target:machine_species = {
								create_species = {
									name = THIS
									plural = THIS
									adjective = THIS
									name_list = THIS
									class = ROBOT
									portrait = THIS
									homeworld = THIS
									traits = THIS
									effect = {
										save_event_target_as = mechanical_species
									}
								}
							}
							assimilate_species_traits_machine_to_robot = yes
							modify_species = {
								base = event_target:machine_species
								species = event_target:mechanical_species
								add_traits_at_start_of_list = yes
								add_trait = trait_mechanical
								remove_trait = trait_machine_unit
								effect = {
									set_species_flag = mechanical_species_of_machine_species@event_target:machine_species
									save_event_target_as = mechanical_species
								}
							}
						}
						else = {
							# setup for next loop iteration
							ROOT = { remove_country_flag = found_assim_mech_species@event_target:machine_species }
						}
						change_species = event_target:mechanical_species
						ensure_species_rights_and_take_ownership_of_leader = yes
						fire_on_action = { on_action = on_leader_species_changed }
					}
					else_if = {
						limit = { is_eligible_for_synthetic_assimilation_species = yes }
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_tech_assimilation
						}
						# if you convert them to synths, you lose the secret hive magic
						if = {
							limit = { has_leader_flag = former_gestalt_ruler }
							remove_leader_flag = former_gestalt_ruler
						}
						change_species = event_target:potential_owner
						change_leader_portrait = event_target:potential_owner
						ensure_species_rights_and_take_ownership_of_leader = yes
						fire_on_action = { on_action = on_leader_species_changed }
					}
					else_if = {
						limit = { is_eligible_for_cybernetic_assimilation_species = yes }
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_tech_assimilation
						}
						modify_species = {
							species = species
							add_trait = trait_cybernetic
							add_traits_at_start_of_list = yes
							change_scoped_species = no
							effect = {
								save_event_target_as = cyborg_species
							}
						}
						if = {
							limit = { event_target:cyborg_species = { has_trait = trait_self_modified } }
							modify_species = {
								base = species
								species = event_target:cyborg_species
								remove_trait = trait_self_modified
								change_scoped_species = no
								effect = {
									save_event_target_as = cyborg_species
								}
							}
						}
						change_species = event_target:cyborg_species
						ensure_species_rights_and_take_ownership_of_leader = yes
						fire_on_action = { on_action = on_leader_species_changed }
					}
					else_if = {
						limit = { is_eligible_for_psionic_assimilation_species = yes }
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_psi_assimilation
						}
						modify_species = {
							species = species
							add_trait = trait_psionic
							add_traits_at_start_of_list = yes
							change_scoped_species = no
							effect = {
								save_event_target_as = psionic_species
							}
						}
						if = {
							limit = { event_target:psionic_species = { has_trait = trait_latent_psionic } }
							modify_species = {
								base = species
								species = event_target:psionic_species
								remove_trait = trait_latent_psionic
								change_scoped_species = no
								effect = {
									save_event_target_as = psionic_species
								}
							}
						}
						if = {
							limit = { event_target:psionic_species = { has_trait = trait_self_modified } }
							modify_species = {
								base = species
								species = event_target:psionic_species
								remove_trait = trait_self_modified
								change_scoped_species = no
								effect = {
									save_event_target_as = psionic_species
								}
							}
						}
						change_species = event_target:psionic_species
						ensure_species_rights_and_take_ownership_of_leader = yes
						fire_on_action = { on_action = on_leader_species_changed }
					}
					else_if = {
						limit = { is_eligible_for_unhive_assimilation_species = yes }
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_assimilation
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_deassimilation
						}
						modify_species = {
							species = species
							remove_trait = trait_hive_mind
							change_scoped_species = no
							effect = {
								save_event_target_as = unhived_species
							}
						}
						if = {
							limit = { event_target:unhived_species = { has_trait = trait_self_modified } }
							modify_species = {
								base = species
								species = event_target:unhived_species
								remove_trait = trait_self_modified
								change_scoped_species = no
								effect = {
									save_event_target_as = unhived_species
								}
							}
						}
						change_species = event_target:unhived_species
						ensure_species_rights_and_take_ownership_of_leader = yes
						fire_on_action = { on_action = on_leader_species_changed }
					}
					else_if = {
						limit = { is_eligible_transfer_without_assimilation = yes }
						ensure_species_rights_and_take_ownership_of_leader = yes
					}
				}
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
}
}

# necrophage
# ROOT = country, integrator or conqueror
# FROM = country, leader storage
country_event = {
	id = keep_leaders.17
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		has_necroids = yes
		is_necrophage_empire = yes
	}
	immediate = {
		log = "keep_leaders.17 necrophage"
		save_event_target_as = potential_owner
		set_update_modifiers_batch = begin
		FROM = {
			every_owned_leader = {
				limit = { is_eligible_transfer_leader_from_storage = yes }
				if = {
					limit = { is_robotic_species = no }
					if = {
						limit = {
							OR = {
								is_hive_species = yes
								event_target:potential_owner = {
									OR = {
										has_valid_civic = civic_fanatic_purifiers
										has_policy_flag = purge_allowed
									}
								}
							}
							NAND = {
								has_citizenship_type = {
									country = event_target:potential_owner
									type = citizenship_purge
								}
								has_living_standard = {
									country = event_target:potential_owner
									type = living_standard_none
								}
								has_purge_type = {
									country = event_target:potential_owner
									type = purge_necrophage
								}
							}
						}
						set_citizenship_type = {
							country = event_target:potential_owner
							type = citizenship_purge
							cooldown = no
						}
						set_living_standard = {
							country = event_target:potential_owner
							type = living_standard_none
							cooldown = no
						}
						set_purge_type = {
							country = event_target:potential_owner
							type = purge_necrophage
							cooldown = no
						}
					}
					# if you necrophage them, you lose the secret hive magic
					if = {
						limit = { has_leader_flag = former_gestalt_ruler }
						remove_leader_flag = former_gestalt_ruler
					}
					unassign_leader = THIS
					set_owner = event_target:potential_owner
					fire_on_action = { on_action = on_leader_owner_changed }
					change_species = event_target:potential_owner
					change_leader_portrait = event_target:potential_owner
					try_assign_retained_leader_to_former_assignment = yes
					fire_on_action = { on_action = on_leader_species_changed }
				}
				else_if = {
					limit = {
						is_robotic_species = yes
						event_target:potential_owner = { has_full_ai_rights = yes }
						is_bypass_leader_restriction_honored_protectors = yes
					}
					ensure_species_rights_and_take_ownership_of_leader = yes
				}
			}
			destroy_country = yes
		}
		set_update_modifiers_batch = end
	}
	after = {
		# recalculate former ruler country bonuses
		country_event = {
			id = keep_leaders_bonus_traits.20
		}
}
}

# triggered by on_leader_death
# THIS = country
# FROM = leader
country_event = {
	id = keep_leaders.100
	is_triggered_only = yes
	hide_window = yes
	trigger = {
		exists = FROM
		FROM = { has_leader_flag = former_gestalt_ruler }
		any_owned_pop_species = {
			is_same_species = FROM
		}
	}
	immediate = {
		log = "keep_leaders.100 former gestalt leader [From.GetName] death"
		# NOTE: using clone_leader here causes a lot of error logs related to random being used in a forbidden location
		clone_leader = {
			target = FROM
			effect = {
				set_leader_flag = former_gestalt_ruler_clone
				if = {
					limit = { is_lithoid = yes }
					if = {
						limit = { is_hive_species = yes }
						set_age = 40
					}
					else = {
						set_age = 70
					}
				}
				else_if = {
					limit = { is_organic_species = yes }
					if = {
						limit = { is_hive_species = yes }
						set_age = 15
					}
					else = {
						set_age = 40
					}
				}
				save_event_target_as = exiled_former_gestalt_ruler
				exile_leader_as = exiled_former_gestalt_ruler@THIS
			}
		}
		country_event = {
			id = keep_leaders.101
			scopes = {
				from = event_target:exiled_former_gestalt_ruler
			}
			days = 30
			random = 60
		}
	}
}

# the "dead" gestalt leader re-emerges 1-3 months after keep_leaders.100
# THIS = country
# FROM = the exiled leader
country_event = {
	id = keep_leaders.101
	is_triggered_only = yes
	title = keep_leaders.101.title
	desc = {
		text = keep_leaders.101.desc
		trigger = {
			is_hive_empire = no
			is_machine_empire = no
		}
	}
	desc = {
		text = keep_leaders.101.desc.hive
		trigger = {
			is_hive_empire = yes
		}
	}
	desc = {
		text = keep_leaders.101.desc.mach
		trigger = {
			is_machine_empire = yes
		}
	}
	picture = {
		trigger = {
			FROM = { is_organic_species = yes }
		}
		picture = GFX_evt_hive_mind
	}
	picture = {
		trigger = {
			FROM = { is_robotic_species = yes }
		}
		picture = GFX_evt_machine_sapience
	}
	show_sound = {
		trigger = {
			FROM = { is_organic_species = yes }
		}
		sound = event_evolution_mastery
	}
	show_sound = {
		trigger = {
			FROM = { is_robotic_species = yes }
		}
		sound = event_synthetic_evolution
	}
	trigger = {
		exists = FROM
		FROM = { has_leader_flag = former_gestalt_ruler_clone }
		any_owned_pop_species = {
			is_same_species = FROM
		}
	}
	immediate = {
		log = "keep_leaders.101 former gestalt leader [From.GetFirstName] respawned"
	}
	option = {
		name = INCREDIBLE
		custom_tooltip = keep_leaders.101.a.tooltip
		hidden_effect = {
			clone_leader = {
				target = FROM
				effect = {
					set_leader_flag = former_gestalt_ruler
				}
			}
			FROM = { kill_leader = { show_notification = no } }
		}
	}
}